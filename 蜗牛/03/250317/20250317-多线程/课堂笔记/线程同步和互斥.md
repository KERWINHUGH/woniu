# 线程同步和互斥

## 一、线程之间的同步和互斥机制

> 当多个线程同时写入文件时，很有可能会发生数据混乱。
>
> 或者面临很多其他的业务场景，比如多个线程在执行时全局变量同时只能有一个线程能够修改。
>
> 或者两个线程交替执行，比如一个线程输出偶数，一个线程输出奇数

##### 1、线程同步相关概念

（1）同步

**同步**是指在多个线程执行过程中，需要协调多个线程之间的执行顺序和资源访问，以确保它们能够正确、有序地共享数据和执行任务的这个过程的统称。例如，一个线程需要等待另一个线程完成特定任务后才能继续执行（比如线程B会在线程A执行之后再执行），或者同时有多个线程访问同一个资源，需要保证数据的一致性。完成线程之间的同步涉及多方面，主要有以下几种：

- **顺序执行**：多个线程的执行顺序是按照预想顺序执行
- **互斥**：同一时间只能有一个线程访问指定共享资源，其他要访问该资源的线程就等待 。比如一个文件的写，或者改变一个全局变量的值   
- **线程之间的通信**：可以实现多个线程更加复杂的同步操作。比如一个线程先执行一部分，然后等待另一个线程唤醒然后继续执行（例子：定义两个线程交替打印奇偶数）

![image-20240508015718852](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240508015718.png)

（2）顺序执行

概念：顺序执行是指多个线程按照一定顺序依次执行（比如创建线程的顺序），这种一般适合对代码执行顺序有严格要求的情况。能够实现同步的主要方式如下所示：

- 借助pthread_join
- 信号量
- 条件变量

（3）互斥

互斥是指确保任一时刻只有一个线程能访问该资源的一种机制。互斥主要用于保护共享资源，如全局变量、数据结构等。也就是说互斥是为了保护资源同一时间只能被一个线程访问的一种机制。实现互斥的方式有以下几种

- **互斥锁**（Mutex）：一种最基本的同步机制，用来保护临界区，确保同一时间只有一个线程可以执行临界区代码。
- **读写锁**（Read/Write Locks）：允许多个读操作同时进行，但写操作需要独占访问。适用于读多写少的场景。
- **自旋锁**（Spinlocks）：当锁不可用时，线程不断循环检查锁的状态，适用于锁只被持有很短时间的场景

（4）线程之间的通信

有的时候我们需要通过一些手段来让不同线程之间近些协同工作以及共享数据。主要的方式有：

- 共享进程数据：同一个程序里的线程可以直接使用全局数据，也可以通过传参的形式来完成数据通信
- 条件变量：条件变量允许线程在某个特定条件满足之前等待，并在条件满足时被另一个线程进行通知继续执行。可以实现多个线程交替执行
- **信号量**：信号量是一种计数器，用于控制多个线程对共享资源的访问。通过信号量，线程可以实现同步和互斥，从而进行有效的通信

![image-20240508021034401](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240508021034.png)





##### 2、同步实现（顺序执行）：信号量

（1）信号量概念

信号量（Semaphore）是一种用于解决多线程（或进程）同步的一种机制，它的核心是维护了一个整数值，用于控制**多个线程**对共享资源的访问数量，也可以用来实现线程之间的顺序执行。而头文件`semaphore.h`中也提供了一系列的函数来使用信号量。

```c
#include <semaphore.h>
```

理解：信号量是一种完整的机制，只不过它的核心点 是一个数字，该数字就控制当前可以访问共享资源的线程个数。我们可以通过调用信号量机制提供的函数来完成线程间的同步（主要是互斥以及顺序执行，也可以用于线程间的通信（较少））

（2）信号量的两种操作

- `P（Proberen：荷兰语中的测试，为阻塞原语）` 操作（也称为 `wait` 或 `down` 操作）：线程尝试减少信号量的值。如果信号量的值大于0，则将其减1，并且线程可以继续执行；如果信号量的值为0，则线程通常会被阻塞，直到信号量的值变为正数。在POSIX线程库中，对应的函数是`sem_wait`或`sem_trywait`
- `V（Verhogen:荷兰语中的增加）` 操作（也称为 `signal` 或 `up` 操作）：线程尝试增加信号量的值。这个操作通常会唤醒一个或多个等待该信号量的线程，允许它们继续执行。在POSIX线程库中，对应的函数是`sem_post`

（3）信号量具有的主要特性

- **原子操作**：信号量的 `P` 和 `V` 操作通常是原子性的，这意味着这些操作在执行过程中不会被其他操作打断。也就是说不会出现两个线程同时操作同一个信号量的情况。
- **阻塞和唤醒**：信号量的 `P` 操作可以阻塞线程，直到信号量的值变为正数，而 `V` 操作可以唤醒一个或多个等待的线程。

![image-20240508101619545](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240508101619.png)

（4）信号量的作用

​	解决多线程或多进程环境中的同步问题

（5）信号量相关函数

**P操作：**尝试减少信号量的值

1. sem_wait

   - 概念：用于等待线程尝试获取信号量。如果信号量的值大于0，则将其减1并立即返回。如果信号量的值为0，则该线程将被阻塞，直到信号量的值大于0。

   - 语法

     ```c
     int sem_wait(sem_t *sem);
     ```

   - 参数

     - `sem`: 指向要操作的信号量的指针。

   - 返回值

     - 成功时，返回0。
     - 失败时，返回-1，并设置`errno`来指示错误类型。

   - 查看信号量限制

   ```c
   cat /proc/sys/kernel/sem
   ```

**V操作**：释放信号量，即+1

2. sem_post

- 概念：释放信号量，增加信号量的值，并唤醒其中一个等待该信号量的线程（等待队列，先进先出）
- 语法

````c
int sem_post(sem_t *sem);
````

- 参数
  - `sem`: 指向要操作的信号量的指针
- 返回值
  - 成功时，返回0。
  - 失败时，返回-1，并设置`errno`来指示错误类型。
- 注意点：
  - 如果一个信号量初始化大于0，那么如果有等该信号量的线程会立即执行。否则就需要调用`sem_post`来增加信号量
  - 信号量建议都在主线程中进行初始化，那怕为0.避免线程直接被迫阻塞

**其他**：初始化以及销毁

3. sem_init

- 概念：用于初始化一个未命名的信号量。
- 语法

```c
int sem_init(sem_t *sem, int pshared, unsigned int value);
```

- 参数
  - `sem`: 指向要初始化的信号量的指针。
  - `pshared`: 如果为0，表示信号量将在进程内的所有线程之间共享；如果非0，表示信号量将在进程之间共享。
  - `value`: 信号量的初始值。
- 返回值
  - 成功时，返回0。
  - 失败时，返回-1，并设置`errno`来指示错误类型。

4. sem_destroy

- 概念：用于销毁一个信号量。在销毁之前，必须确保没有线程正在等待该信号量。
- 语法

```c
int sem_destroy(sem_t *sem);
```

- 参数
  - `sem`: 指向要销毁的信号量的指针。
- 返回值
  - 成功时，返回0。
  - 失败时，返回-1，并设置`errno`来指示错误类型。

（6）信号量的使用一般步骤

> 为什么要使用信号量？
>
> - 解决周步问题
>   - 线程执行顺序，或交替执行
>   - 同一时间只有一个线程能够使用共享资源（全局变量）

- 初始化一个信号量，一般是全局变量，在，main函数里调用初始化函数`sem_init`,初始值由业务逻辑来决定。
- 在线程要访问资源时（该资源由该信号量控制访问数量），线程需要等待该信号量，即调用`sem_wait`
- 线程访问结束后一般会调用`sem_post`让信号量+1，让其他等待该信号量的线程有访问数量（信号量+1）
- 如果该信号量不再使用，就需要进行销毁，调用`sem_destroy`

（7）多线程之间的顺序执行代码例子

- 入门案例：

> 两个线程顺序执行： 默认信号量初始化为0，让后执行的线程执行代码第一句进行等待信号量，让先执行的线程执行后增加该信号量即可。

```c
/***************************************************
# File Name:    多线程-07信号量控制执行顺序
# Author:       SuperYu
# Mail:         yujian001002@163.com.com
# Created Time: 2024年11月25日 星期五 23时41分58秒
****************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

sem_t sem1; // 控制 A 线程
sem_t sem2; // 控制 B 线程

void* demoA(void* args) {
    char *name = (char*)args;
    for (int i = 1; i <= 10; i += 2) {
        sem_wait(&sem1); // 等待 B 线程的信号
        printf("%s线程执行:%d\n", name, i);
        sem_post(&sem2); // 释放信号给 B 线程
    }
    return NULL;
}

void* demoB(void* args) {
    char *name = (char*)args;
    for (int i = 0; i <= 10; i += 2) {
        sem_wait(&sem2); // 等待 A 线程的信号（首次直接运行）
        printf("%s线程执行:%d\n", name, i);
        sem_post(&sem1); // 释放信号给 A 线程
    }
    return NULL;
}

int main() {
    // 初始化信号量
    sem_init(&sem1, 0, 0); // A 线程需要等待 B 的信号
    sem_init(&sem2, 0, 1); // B 线程先执行

    pthread_t pid1, pid2;
    pthread_create(&pid2, NULL, demoB, "B"); // 创建 B 线程
    pthread_create(&pid1, NULL, demoA, "A"); // 创建 A 线程

    pthread_join(pid1, NULL);
    pthread_join(pid2, NULL);

    // 销毁信号量
    sem_destroy(&sem1);
    sem_destroy(&sem2);

    return 0;
}
```

练习：

> 利用同步和互斥来解决以下问题；定义三个线程，分别可以打印A、B、C。利用同步和互斥来实现最终打印BCABCABCA
>
> 实现思路
>
> 1. **定义三个信号量**：
>    - `semA`: 控制打印 `A` 的线程。
>    - `semB`: 控制打印 `B` 的线程。
>    - `semC`: 控制打印 `C` 的线程。
> 2. **信号量的初始值**：
>    - 设置 `semB` 的初始值为 1，使 `B` 的线程先执行。
>    - 设置 `semA` 和 `semC` 的初始值为 0，使它们等待信号。
> 3. **线程交替逻辑**：
>    - 线程 `B` 运行后唤醒线程 `C`。
>    - 线程 `C` 运行后唤醒线程 `A`。
>    - 线程 `A` 运行后唤醒线程 `B`。
>    - 如此循环，直到打印完成。