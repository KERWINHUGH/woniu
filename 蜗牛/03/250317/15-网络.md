### 课堂引入

> 我们早习惯了网络的存在，无论是手机聊天，在线冲浪，还是打游戏，网络无处不在。在嵌入式系统中网络也非常重要，比如物联网，我们需要手机能够操作智能设备来完成功能，比如控制空调、电视、汽车等。所以学习网络的形成以及设计网络程序是非常重要的板块。一阶段我们会学习网络的基本概念以及学习如何利用网络完成两台电脑之间的通信

![image-20240326110109082](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240326110109.png)



#### 一、网络相关概念

##### 1、互联网的发展概括

（1）为了更好应对和苏联的军事竞赛，1958美国成立了ARPA部门，开发了内部联网技术- ARPANET（因特网的前身）方便不同部门之间可以快速沟通，开发ncp协议作为早期网络的通信协议。

（2）70年代末，随着链接ARPANET的电脑节点不断增加，美国开发了**tcp/ip**，并代替旧的网络通信协议（ncp）作为军事内部的标准通信协议

（3）1983，ARPANET分裂成军用和民用两部分，民用部分随着全社会的加入，因特网从而开始崭露头角，这个是离不开tcp\ip协议的推进。

（4）1984，国际标准化组织（iso）发布了**OSI七层网络通信协议**，成为更全面、标准化的理论框架，但此时**tcpip协议**已经成为了实际应用的**网络通信协议**。

**小结**：实际计算机之间的通信中，tcpip是完成通信的协议，而osi七层模型是一个理论通信协议框架，osi对于网络通信过程的理解有帮助。

##### 2、tcpip四层模型

（1）概念

是指整个**网络通信协议家族的整合**，它构成了互联网的基础通讯架构,为当前互联网的**实际网络通信标准协议**，实现了不同的计算机能够进行互联（因特网-Internet）。

协议：双方为了某个目的进行协定共同遵守的规定，比如结婚协议，学员管理协议等。网络协议指的是为了完成不同计算机之间进行数据通信而制定的规则或标准。网络协议有很多，不同的协议在网络通信的整个过程中发挥着不同的作用。

**tcp、ip四层模型：指完成计算机网络通信的以tcp、ip协议为核心的整个网络协议集合（家族），根据处理 流程大致将这些协议分为四层。每一层都有很多网络协议进行协同工作。所有的网络协议协同工作完成了不同计算机之间的数据交互（网络通信）**

（2）特点

- tcpip简化了osi七层模型，为4层模型，每层负责不同的通信任务

（3）具体模型

![image-20240326114054742](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240326114054.png)

（4）每层的作用

| tcp/ip中的层 | 功能                                 | TCP/IP协议族                       |
| ------------ | ------------------------------------ | ---------------------------------- |
| 应用层       | 文件传输,电子邮件,文件服务,虚拟终端  | TFTP,HTTP,SNMP,FTP,SMTP,DNS,Telnet |
| 传输层       | 提供端对端的接口                     | TCP,UDP                            |
| 网络层       | 为数据包选择路由                     | IP,ICMP,RIP,OSPF,BGP,IGMP          |
| 网络接口层   | 以二进制数据形式在物理媒体上传输数据 | ISO2110,IEEE802.1,EEE802.2         |



**应用层**：最靠近用户的一层，它直接为应用程序提供服务。它定义了用于软件应用程序之间通信和数据传输的接口和协议。

- 主要协议：HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）、DNS（域名系统）等
- 功能：为计算机上的应用程序提供数据的通信支持

**传输层**：传输层负责在网络中的两台主机之间进行可靠或不可靠的数据传输。它为两台主机的应用层之间提供端到端的通信

- 主要协议：TCP（传输控制协议）、UDP（用户数据报协议）。
- 功能：确保数据正确、有效地从源端传输到目的端。TCP提供可靠的数据传输，而UDP提供快速但不可靠的数据传输
- 要点：**要强调该层负责数据传输。无论是第三方程序还是开发者自己写的程序**

**网络层**：负责数据包从源到目的地的传输。它定义了数据包的路由选择和转发。

- 主要协议：IP（互联网协议）、ICMP（互联网控制消息协议）、ARP（地址解析协议）、RARP（反向地址解析协议）等。
- 功能：实现跨网络设备的数据传输。它将数据封装成数据包（IP数据报），并使用IP地址进行寻址和路由

 **网络接口层**：网络接口层是TCP/IP协议栈中最底层，处理与物理网络的接口细节。它包括操作系统中的网络驱动程序和网络接口卡，负责在电子信号和数据包之间进行转换。

- 功能：实现数据在物理媒介（如电缆、光纤、无线电波）上的传输。这一层关心的是如何在网络媒介上以帧（frames）的形式传输数据

小结：在整个通信过程中，数据会从应用层向下经过每一层，每一层都会对数据进行封装，添加上该层所需要的头信息，直到网络接口层，然后在另一端，数据会逐层向上被解封装，直到应用层。

理解例子：寄快递

![image-20240326172213571](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240326172213.png)

- 第一步：**要寄什么东西**（小物件一个小口袋就可以，大物品需要一个纸盒）。就像应用层。不同应用程序的数据可能用不同方式（http、smtp、ftp等）来包装数据，然后放送给下一层
- 第二步：将物品放到寄快递店里，并**填写寄件地址和收件地址**，可以选择是否**优享达**服务之类的。这个跟传输层一样，负责端到端的通信，那我得知道源端是谁，目的端是谁。同时为了保证数据正确到达，还会有是否有安全传输可以选择（tcp或udp）
- 第三步：快递员拿到快递之后就会**返回到中转站进行分发**，确保快递的准确可行路径（成都<卡车>---沈阳--中转站--目的地）。网络层也是一样，数据包的寻址和路由，并利用IP协议为每个发送和接收的设备提供一个地址（即IP地址），并决定数据包如何从源头送达目的地（确定正确的分发地址）。
- 第四步：确定路径之后就会通过飞机、火车、卡车等途径**进行实际的寄送快递**。网络接口层也是一样，通过光纤或WiFi等途径传输数据，到达另一个设备。

**小结**：应用层负责要传递或接受什么样的数据，传输层负责确定两端的地址，网络层负责路由的分发和寻址，网络接口层负责实际传输。

（5）数据解析（参考七层osi模型）

##### 3、osi七层模型

（1）概念

**OSI模型**，即**开放式通信系统互联参考模型**（**Open System Interconnection Reference Model**），是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI

（2）特点

- OSI模型是一个<span style="font-size:20px;color:red;font-weight:bold;">理想化</span> 的模型，尚未有完整的实现

（3）七层模型

![image-20240326172841993](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240326172842.png)

（4）每层的作用

| OSI中的层  | 功能                                                         | TCP/IP协议族                       |
| ---------- | ------------------------------------------------------------ | ---------------------------------- |
| 应用层     | 文件传输,电子邮件,文件服务,虚拟终端                          | TFTP,HTTP,SNMP,FTP,SMTP,DNS,Telnet |
| 表示层     | 数据格式化,代码转换,数据加密                                 | 没有协议                           |
| 会话层     | 解除或建立与别的节点的联系                                   | 没有协议                           |
| 传输层     | 提供端对端的接口                                             | TCP,UDP                            |
| 网络层     | 为数据包选择路由                                             | IP,ICMP,RIP,OSPF,BGP,IGMP          |
| 数据链路层 | 传输有地址的帧以及错误检测功能                               | SLIP,CSLIP,PPP,ARP,RARP,MTU        |
| 物理层     | 以二进制数据形式在物理媒体上传输数据。物理层的重点是确保数据比特能够在网络媒介上准确无误地传输 | ISO2110,IEEE802.1,EEE802.2         |

（5）讲解例子

以传输网页数据为例，讲解数据使用osi七层模型协议进行传输的大概过程：

1. **应用层 (Application Layer)**:
   - 浏览器是应用层的软件，它使用HTTP（或HTTPS，如果是加密的）来发起网页请求。当你输入 [www.baidu.com](http://www.baidu.com/) 时，浏览器将这个请求转换为一个 HTTP GET 请求。
   - 作用：将网页地址包装成一个数据（数据按照http协议来包装），包装后交给表示层继续处理
2. **表示层 (Presentation Layer)**:
   - 该层确保发送的数据在网络上可以被接收端理解。例如，如果浏览器需要加密请求（假设使用 HTTPS），则加密发生在这一层。同时也处理数据压缩和格式转换。
   - 作用：将应用层发来的数据进行加密/解密，以及压缩/解压缩处理，处理后交给会话层处理。实际上tcp/ip协议处理完数据后交给传输层处理。
3. **会话层 (Session Layer)**:
   - 这一层在你的浏览器和服务器之间建立、管理和终止通信会话。它处理会话的开始和结束，并确保长时间无响应的会话被关闭。
   - 确保浏览器和远程要通信的另一台电脑（服务器）建议里通信通道。
4. **传输层 (Transport Layer)**:
   - 浏览器决定使用 TCP（传输控制协议）来确保数据的可靠传输。HTTP 请求被分割成 TCP 数据包，并对它们进行排序和校验以确保无误的到达。其他数据可能采用udp来进行数据传输（比如视频和音频），
   - 作用：决定采用tcp还是udp方式传输数据，决定后包装数据，传递给网络层进行处理
5. **网络层 (Network Layer)**:
   - 此时，请求需要被发送到互联网上。但是首先，通过 DNS 解析服务会将 [www.baidu.com](http://www.baidu.com/) 转换成一个 IP 地址。接着，路由器使用 IP 协议来确定最佳路径以传递数据包到目标 IP 地址。将这些信息整合到上一层发来的数据后继续传递给下一层处理
6. **数据链路层 (Data Link Layer)**:
   - 数据包在这一层被转换成帧，并准备发送到本地网络。在这个层次中添加了物理地址（MAC地址）。 如果数据需要通过 Wi-Fi 或以太网传输，这个层次负责定义数据如何在这些物理媒体上格式化和发送。
7. **物理层 (Physical Layer)**:
   - 最后，数据在物理层以电信号传输到你的本地路由器，然后通过你的 ISP 到达互联网，最终到达服务器的物理硬件。在服务器端，这个过程以相反的顺序发生，将电信号转换回数据包，然后通向服务器的操作系统和软件。

在服务器处理完请求后（如查找网页内容、可能涉及到后台数据库查询等），响应数据会通过服务器的应用层、表示层、会话层、传输层、网络层、数据链路层和物理层重新发送回你的电脑。完成这个过程后，你的浏览器将收到的数据组装成一个可以显示的网页，然后你就可以看到 [www.baidu.com](http://www.baidu.com/) 的主页了。

![88143230149153229173166227128139-01](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240327104544.gif)



##### 4、网络协议大全

| 协议名称                     | 作用                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| HTTP(应用)                   | 用于对浏览器等web服务提供网络服务，数据为网页内容            |
| FTP                          | 文件传输协议，比如老师电脑向学生电脑传文件                   |
| SMTP                         | 简单邮件传输协议                                             |
| DNS                          | 域名解析系统，[www.woniuxy.com](www.woniuxy.com) ->101.37.65.91 |
| TCP（传输层）                | 传输控制协议，提供可靠的连接导向服务.提供了端到端之间的可靠传输通道 |
| UDP                          | 用户数据报协议，提供无连接的快速传输服务                     |
| IP（网络层）                 | 网际协议，IP协议定义了地址系统（如IPv4和IPv6）、数据包结构和路由功能 |
| ICMP                         | ICMP用于传递控制消息，比如传达网络中存在的问题。它常被用来诊断网络通信问题，例如“ping”命令就使用了ICMP来检测另一台计算机是否可达 |
| ARP                          | 地址解析协议，ARP用于把网络层的IP地址转换为数据链路层的物理地址（如以太网MAC地址） |
| RARP                         | 逆地址解析协议，RARP的作用与ARP相反，它由网络设备使用，用于将物理地址（MAC地址）转换为IP地址 |
| OSPF                         | 开放最短路径优先，OSPF是一种内部网关协议，用于在单个自治系统（AS）内部确定路由的最短路径，使用算法动态计算出网络中各路由器到达目的地的最佳路径，ospf用于某个as内部 |
| BGP                          | 边界网关协议，是互联网上用于路由和达成自治系统（AS）之间最佳路径决策的协议，bgp用于不同as之间的互联 |
| Ethernet（数据链路层）       | Ethernet(以太网)是最为广泛使用的局域网技术，提供了包括物理地址维护、帧分界和控制、错误检测和更正等服务 |
| PPP                          | PPP是一个用于直接连接两端节点的协议，比如在用户和互联网服务提供商之间的连接 |
| HDLC                         | 高级数据链路控制协议用于同步数据链路层的错误检查和流量控制   |
| VLAN                         | VLAN技术允许在同一物理网络上创建多个逻辑子网，有助于管理大型网络，提高了安全性和网络管理的灵活性 |
| ATM                          | ATM是一种以固定长度的单元进行数据传输的技术，这些单元在ATM网络中被称为细胞或单元。ATM适合于语音、视频和数据等类型的传输 |
| IEEE 802.3（物理层技术标准） | 与以太网相关的一系列标准，定义了包括物理层电气和物理数据的接口的细节 |
| V.35                         | 在串行通信中用于较高数据速率的物理连接标准                   |
| EIA/TIA-232                  | 原称RS-232，标准化了在串行通信端口上使用的信号，包括连接器的类型和使用 |
| G.703                        | 由国际电信联盟（ITU）定义的用于传输数字信号的物理层规格      |

##### 5、总结

（1）协议

协议是指一种规则和约定，也可以用于指定一个事物的标准。比如网络协议就是用于网络中的数据交换方式和通讯过程应该是怎样的，或者员工管理、学员管理等是一种约定。

网络协议分很多种，而不同的网络协议负责网络通信中不同的部分。而实际中规定网络通信的是以**tcp、ip为核心**的协议族。而与之对应的osi七层模式是一种理想上的网络通信协议，但没有普及，更多的是一个指导作用。

每一层都有很多小的协议在协同一起完成该层的网络通信工作。

![image-20240428223316610](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240428223316.png)

（2）osi七层模型

- **物理层**：最底层，负责在物理媒介（如电缆、光纤或无线电波）上转发原始的比特流
- **数据链路层**：此层负责在相邻节点间的可靠链接，确保数据准确无误地传输。简单来说，它确保比特组成的帧在网络设备间传输没有错误。
- **网络层**：负责将数据包从源头传到目的地，涉及不同网络间的路由选择。即数据包的地址以及选择最佳路径到达目的地
- **传输层**：这一层确保数据的顺利传输，提供可靠的数据传输服务（也可以选择不可靠的udp）
- **会话层**：会话层管理和维护网络中两个节点之间的通讯连接会话。它负责建立、管理以及断开通信会话。但在tcpip中，是传输层提供了会话的连接
- **表示层**：此层负责数据的转换和编码，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。这一层也是被tcpip中的应用层给代替了。
- **应用层**：最靠近用户的层，它为应用软件提供网络服务。

（3）tcp ip四层模式

- **应用层**：代替osi前三层。为应用程序提供网络服务，包括数据的表示、编码和解码等
- **传输层**：为两台主机上的应用程序提供端到端的通信，包括数据分段和重组，流量控制，错误检测和纠正
- **网络层**：负责数据包的路由和转发，提供逻辑地址（如 IP 地址），确保数据包能够跨多种物理网络从源头到达目的地
- **链路层**：负责在物理媒介上发送和接收数据帧，包括处理 MAC 地址（物理地址）、帧的封装和解封装、错误检测和修正。代替osi最后两层。

![image-20240428222832664](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240428222832.png)

#### 二、网络应用程序设计模式

计算机大多数应用程序都需要网络支持，而我们也可以称这些需要网络才能使用的应用程序为网络应用。根据设计不同将所有的网络应用简单分为两种设计模式

- **C/S（Client/Server）架构**：
- **B/S（Browser/Server）架构**：

##### 1、两种设计模式

（1）C/S模式

​			传统的网络应用设计模式,客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。比如桌面应用程序或大多数游戏客户端

![image-20240327115029707](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240327115029.png)

（2）B/S模式

​			浏览器(browser)/服务器(server) 模式。只需在一端部署服务器,另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。比如浏览器。

![image-20240327115056981](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240327115057.png)

##### 2、优缺点

（1）C/S（Client/Server）架构

- 优点
  - 网络自主性：一些客户端可以在没有网络或网络不稳定的情况下工作，比如格式工厂。
  - 性能较高：客户端可以利用本地资源计算和处理数据，速度较快。
  - 安全性：相对于B/S架构，客户端与服务器的通信可以更加容易地保证安全。
- 缺点
  - 维护复杂：每个客户端的应用程序都需要单独安装和更新。
  - 不易跨平台：不同操作系统的客户端需要开发不同版本的软件。

（2）B/S（Browser/Server）架构

- 优点
  - 简化客户端维护：用户通过浏览器访问应用，不需要单独安装客户端软件。
  - 跨平台：Web应用可以在不同操作系统的浏览器上运行。
  - 易于升级维护：服务器端更新后，所有用户都能访问到最新版本的应用。
- 缺点
  - 网络依赖性强：需要持续的网络连接。
  - 安全性：Web应用相对容易受到网络攻击。
  - 性能：相比本地应用，Web应用可能响应速度较慢。

（3）应用场景区别

- C/S架构：专业软件、游戏
- B/S架构：网页应用、在线办公



#### 三、TCP 套接字（socket）网络编程

##### 1、网络套接字编程

（1）网络编程

网络套接字编程是一种方式，使得**不同的程序**之间能够进行网络通信，通常涉及数据在不同的计算机之间的传输。套接字（Socket）是计算机网络数据传输的一个抽象层，它为我们提供了发送和接收数据的方式(编程语法)。通过网络套接字编程，我们可以实现不同设备之间或同一设备上的不同进程（或线程）之间的数据交换。根据数据传输使用协议的不同分为两种套接字编程

- **tcp套接字编程**
- udp套接字编程

![image-20240429125634901](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240429125634.png)

（2）套接字概念

套接字是一种抽象概念，用于**描述不同计算机上的程序（或同一计算机上的不同进程）如何通过网络进行数据交换**。在程序中，**套接字表现为一个包含IP地址、端口号以及指定的协议（例如TCP或UDP）的数据结构**。客户端和服务器双方都各有一个套接字来描述本身，方便在数据传输中进行**身份确认**，即一个套接字指向客户端，另一个套接字指向服务器。例子：文件流指针区分要操作的文件。套接字区分要访问网络的程序

而c语言提供了一套以套接字为核心的内置函数，用于开发者进行网络数据通信。函数内部隐藏了发送数据的细节，开发者不需要关心底层网络协议的运作，简化了网络编程难度。

![image-20240327172651266](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240327172651.png)

**注意**：因为套接字编程是需要开发者自己编写程序，无法使用浏览器，**所以采用c/s架构来编写。也就是说会有一个客户端程序和服务器端程序**。

**客户端**：负责链接服务器端以及接受服务器返回的数据，当然也可以发送数据给服务器去处理。

**服务器**：负责接受和处理客户端连接的请求以及发送数据给客户端，也可以接受客户端发送过来的数据。

客户端连接服务器端程序的前提是服务器端得处于运行中。程序一定是先确保服务器处于正常运行中，才会运行客户端程序用于连接服务器并进行数据交互。

ip地址：每个电脑上网的编号（一台电脑在互联网的身份证）。是一串数字和点的集合(192.168.1.1)。但是用户来说记不住要访问服务器的ip地址。那么就可以使用域名来代替ip地址。例子。比如浏览器地址栏输入www.woniuxy.com,电脑就会根据该域名查找到对应服务器电脑的ip地址并进行访问。

端口号：电脑里的每个软件如果要上网，必须要操作系统为其分配一个端口号用于进行网络通信。端口号本质上是一个数字，范围是0~65535.系统预定占用的一般为0~1023,1023到50000之间是各个应用程序可以分配的端口号，后续的处于备用状态。比如远程登录软件一般使用22或443端口，浏览器一般使用8080端口来进行网络数据交互。8888  7777 9999 10001 6666

（3）套接字分类

- 流式套接字(SOCK_STREAM):

  - 提供了一个面向连接、可靠的数据传输服务,数据无差错、无重复的发送且按发送顺序接收。内设置流量控制,避免数据流淹没慢的接收方。数据被看作是字节流,无长度限制。tcp套接字推荐使用

- 数据报套接字(SOCK_DGRAM):

  - 提供无连接服务。数据包以独立数据包的形式被发送,不提供无差错保证,数据可能丢失或重复,顺序发送,可能乱序接收。推荐udp使用

- 原始套接字(SOCK_RAW): 

  - 可以对较低层次协议如IP、ICMP直接访问。使用的少

  <img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240327190109.png" alt="image-20240327190109073" style="zoom:67%;" />

##### 2、tcp套接字简介

（1）概念

顾名思义，tcp套接字是指使用tcp协议的网络套接字编程，意味着**发送的数据能准确无误地**从一个端点传输到另一个端点。而tcp本身是一种**面向连接的**、**可靠的**、**基于字节流**的传输层通信协议。在应用层看来，TCP 套接字提供了一个端到端的通信通道，允许两台主机上的应用程序交换数据流。

（2）特点

**可靠性**：TCP提供可靠的数据传输服务，它确保数据正确无误地从发送端传输到接收端

**错误检测**：TCP通过校验和来检测数据在传输过程中的任何错误。如果检测到错误，相关数据包可以被丢弃并要求重新发送

**拥塞控制**：TCP能够监测网络中的拥塞，自动调整数据发送的速率来减少网络的负担

基于tcp以上的特点，**我们在发送数据时，基本只需要考虑业务和代码的逻辑性**，其他套接字会帮我们解决。

##### 3、涉及函数

（0）需要引入的头文件

```c
#include <arpa/inet.h>
#include <sys/socket.h>
//用于互联网地址族，包括 sockaddr_in 结构和 IP 地址定义。
#include <netinet/in.h>
```

（1）定义一个套接字

```c
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
例子：采用可靠的tcp进行通信
int client_fd = socket(AF_INET,SOCK_ST)
```

- 参数:
  - domain: 指定套接字使用的协议族。常见的协议族有 `AF_INET`(IPv4 网络协议)，`AF_INET6`(IPv6 网络协议)，`AF_UNIX`(本地通信，使用UNIX文件系统的路径名)。
  - type: 套接字数据传输的类型信息。
    -  `SOCK_STREAM`（提供顺序化的、可靠的、双向的、基于连接的字节流，使用TCP协议）
    - `SOCK_DGRAM`（支持无连接的数据包服务，使用UDP协议）
  - protocol: 计算机间通信中使用的协议信息。通常是 `IPPROTO_TCP` 用于 TCP 套接字，`IPPROTO_UDP` 用于 UDP 套接字。如果 `type` 或 `domain` 能唯一确定协议，这个参数也可以设置为0，让系统自动选择合适的协议
- 返回值:
  - 成功: 返回文件描述符
  - 失败: 返回-1

（2）connect

- 概念：用于链接某个服务器

- 语法

  ```c
  int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
  ```

- 参数

  - `int sockfd`：这是指向一个打开的socket的套接字描述符，该socket是通过调用 `socket()` 函数创建的。
  - `const struct sockaddr *addr`：这是一个指向 `struct sockaddr` 结构体的指针，该结构体包含了目标服务器的地址和端口信息。通常，你会使用特定于地址族的结构体（例如对于IPv4是 `struct sockaddr_in`），并将其强制转换为 `struct sockaddr` 类型的指针传递给 `connect`。
  - `socklen_t addrlen`：这是上述addr指向的地址结构的长度。

- 返回值

  - 如果连接建立成功，`connect` 函数返回 `0`。
  - 如果连接失败，返回 `-1`，并且 `errno` 被设置为具体的错误代码

- 例子

  ```c
  if (connect(sockfd, (struct sockaddr *)&server, sizeof(server)) == -1)
  {
      perror("connect");
      exit(-1);
  }
  ```

（3）accept

- 概念

  会阻塞程序执行并等待客户端的连接，有客户端连接后才执行后续的代码。

- 语法

  ```c
  int accept(int sockfd, struct sockaddr *client, socklen_t *addrlen);
  ```

- 参数

  - `int sockfd`：这个参数是由 `socket()` 函数返回的监听socket的文件描述符。该监听socket应已经绑定到一个本地地址和端口上，并且已经在这个端口上监听连接，即在之前已经调用过 `bind()` 和 `listen()` 函数。
  - `struct sockaddr *addr`：这是一个指向 `struct sockaddr` 结构体的指针，这个结构体在函数调用成功后将被填充为接受连接的远程主机的地址信息。实际上，当`accept`函数被调用时，系统会从监听队列中取出排在最前面的连接请求，创建一个新的套接字，并将请求连接的客户端的地址信息填充到这个结构体中。
  - `socklen_t *addrlen`：这是一个指向 `socklen_t` 类型变量的指针，该变量在调用前应该被初始化为addr所指向的地址结构体的大小。`accept`函数成功返回后，这个变量将被设置为实际接收到的地址的长度。

- 返回值

  - 成功时，返回一个新的socket文件描述符，用于与接受的连接进行通信。此描述符代表一个已经建立的连接。
  - 错误时，返回 `-1`，并且 `errno` 被设置为相应的错误码。

- 例子

  ```c
  struct sockaddr_in client_addr;
  socklen_t len = sizeof(client_addr);
  int conn_fd = accept(server_fd, (struct sockaddr*)&client_addr, &len);
  ```

（4）read

- 概念：用于从套接字或任何文件描述符中读取数据

- 语法

  ```c
  ssize_t read(int fd, void *buf, size_t count);
  ```

- 参数

  - `int fd`：文件描述符，用于标识一个打开的文件或套接字。
  - `void *buf`：指向一个缓冲区的指针，这个缓冲区用于存储从文件描述符读取的数据。
  - `size_t count`：指示要读取的最大字节数。

- 返回值

  - 成功时，返回读取的字节数，如果客户端关闭了，返回0
  - 失败时，返回-1，并设置`errno`以指示错误类型。

（5）write

- 概念:用于向套接字或任何文件描述符写入数据。

- 语法

  ```c
  ssize_t write(int fd, const void *buf, size_t count);
  ```

- 参数

  - `int fd`：文件描述符，用于标识一个打开的文件或套接字。
  - `const void *buf`：指向一个包含要写入数据的缓冲区的指针。
  - `size_t count`：指示要写入的字节数。

- 返回值

  - 成功时，返回写入的字节数。在许多系统中，`ssize_t` 是和 `size_t` 一样的宽度，但是是有符号的。例如，在一个32位系统上，`size_t` 通常是一个32位无符号整数，而 `ssize_t` 是一个32位有符号整数
  - 失败时，返回-1，并设置`errno`以指示错误类型。

- **注意**：它们都定义在 `<unistd.h>` 头文件中，这点对于普通文件I/O和套接字I/O都是一样的。当在套接字上使用 `read` 和 `write` 时，实际上是在进行网络I/O操作，这些操作底层由操作系统的网络堆栈来处理。而在普通文件上使用这些函数时，操作的是文件系统I/O。

（6）close

- 概念：关闭一个套接字或任何文件描述符

- 语法

  ```c
  int close(int fd);
  
  ```

- 参数

  - `int fd`：要关闭的文件描述符或套接字的标识符。

- 返回值

  - 成功时，`close` 函数返回 `0`。
  - 失败时，返回 `-1` 并设置全局变量 `errno` 以指示错误的原因。

（7）listen

- 概念

  - 监听指定的端口号：执行这步就可以认为是服务器已启动

- 语法

  ```c
  int listen(int sockfd, int backlog);
  ```

- 参数

  - `int sockfd`：套接字文件描述符，是已经绑定到一个本地地址的套接字。
  - `int backlog`：这个参数定义了套接字可以排队的最大连接数。具体来说，它指定了内核中待处理的连接队列的大小，队列满了之后，内核会拒绝多余的连接请求。

- 返回值

  - 成功时返回0
  - 失败时返回-1

（8）bind

- 概念：绑定结构体

- 语法

  ```c
  #include <sys/socket.h>
  int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);
  ```

- 参数

  - `int sockfd`：套接字文件描述符，是通过调用 `socket()` 函数创建的。
  - `const struct sockaddr *addr`：一个指向 `sockaddr` 结构的指针，该结构保存了要关联到套接字的地址（包括IP地址和端口号）。对于IPv4，这个结构会被类型转换为 `struct sockaddr_in`。
  - `socklen_t addrlen`：该地址的长度，对于IPv4是 `sizeof(struct sockaddr_in)`，对于IPv6是 `sizeof(struct sockaddr_in6)`。

- 返回值

  - 成功时返回0
  - 失败时返回-1

（9）sockaddr_in

- 概念：为`<netinet/in.h>中`，用于描述一个网络通信地址，包含了地址相关信息，一般会配合`connect()或accept()`进行使用

- 组成

  - `sin_family`: 地址家族（Address Family），通常是 `AF_INET`，指的是IPv4网络协议。
  - `sin_port`: 16位的端口号，存储网络字节顺序（通常使用`htons()`函数来设置此值，确保字节顺序正确）。
  - `sin_addr`: 32位IP地址，存储网络字节顺序。其下有一个成员 `s_addr`，表示一个无符号长整型的IP地址。

- 例子

  ```c
  struct sockaddr_in server;
  server.sin_family = AF_INET;//ipv4
  server.sin_port = htons(8080);//设置端口
  server.sin_addr.s_addr = inet_addr("127.0.0.1");//设置ip地址
  ```



（9）recv：效果类似于read

（10）send：

##### 4、大概流程

![image-20240327202506653](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240327202506.png)

**客户端：**

1. 调用socket()创建一个套接字，并指定ip地址和使用协议，得到一个套接字描述符
2. 声明网络结构体用于表示要连接的服务器
3. 调用Connect()尝试连接一个服务器
4. 链接成功之后使用read()或write()进行接受服务器返回的数据或发送数据给服务器
5. 不需要链接之后调用close()关闭套接字，释放套接字所占用的资源。

**服务器端**

1. 调用socket()创建一个套接字，并指定ip地址和使用协议，得到一个套接字描述符
2. 调用bind()绑定一个端口号
3. 调用listen用于监听绑定的端口，可以处理任何发送给该端口的信息（比如客户端发来的，需要accept来处理），这一步服务器就启动了，等待客户端链接
4. 需要手动调用accept来接受客户端的链接
5. 第四步成功之后就可以使用read()或write()来完成数据的交互
6. 不需要链接之后调用close()关闭套接字，释放套接字所占用的资源。

##### 5、具体例子(hello world-单次)：

（1）客户端

```c
#include <arpa/inet.h>
#include <sys/socket.h>
//用于互联网地址族，包括 sockaddr_in 结构和 IP 地址定义。
#include <netinet/in.h>
int main(){
	//客户端
	//1. 创建套接字
	int client_fd = socket(AF_INET,SOCK_STREAM,0);
	if(client_fd==-1){
		perror("socket open()");
		exit(0);
	}
	//2 声明结构体用于表示要连接服务器的信息
	struct sockaddr_in  server;
	server.sin_addr.s_addr = inet_addr("127.0.0.1");
	server.sin_family = AF_INET;
	server.sin_port = htons(8081);//网络字节序，网络传输统一格式
	//3 连接服务器
	if(connect(client_fd,(struct sockaddr*)&server, sizeof(server))<0){
		perror("连接失败");
        close(client_fd);
        exit(EXIT_FAILURE);
	}
	puts("连接成功");
	//发送数据
	char str[100]="hello server";
	int count = write(client_fd,str,strlen(str));
	printf("count=%d\n",count);
	puts("向服务器发送数据");
	close(client_fd);
    return 0;
}

```

（2）服务器端

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//这个头文件定义了如 read(), write(), 和 close() 等 POSIX 操作系统API。
#include <unistd.h>
//提供字节顺序转换（比如主机字节序和网络字节序的转换）和地址转换的函数
#include <arpa/inet.h>
//包含了套接字相关的函数原型和数据结构，例如 socket(), connect(), accept(), bind(), listen() 和 shutdown().
#include <sys/socket.h> 
//用于互联网地址族，包括 sockaddr_in 结构和 IP 地址定义。
#include <netinet/in.h>
int main(){
	//1.创建服务器套接字
	int server_fd = socket(AF_INET,SOCK_STREAM,0);
	if(server_fd <0){
		perror("socket()服务器");
		exit(0);
	}
	//2. 设置端口ip地址等信息
	struct sockaddr_in server_addr,client_addr;
	memset(&server_addr,0,sizeof(server_addr));
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = INADDR_ANY;
	server_addr.sin_port=htons(8081);
	//3. 绑定服务器结构体
	if(bind(server_fd,(struct sockaddr *)&server_addr,sizeof(server_addr))<0){
		perror("bind ()");
		exit(0);
	}
	//4. 监听端口
	if(listen(server_fd,1)<0){
		perror("listen()");
		exit(0);
	}
	puts("服务器正在监听8081");
	socklen_t client_addr_len=sizeof(client_addr);
	//5. 接受客户端连接
	int client_fd=accept(server_fd,(struct sockaddr*)&client_addr,&client_addr_len);
	if(client_fd<0){
		perror("accept()");
		exit(0);
	}
	puts("客户端连接成功");
	//6. 进行读写
	char buf[60];
	int count = read(client_fd,buf,sizeof(buf)-1);
	if(count <0){
		puts("读取错误");
	}else{
		buf[count]='\0';
		printf("接收到的数据为:%s\n",buf);
		//发送数据
		char *res="收到信息！";
		write(client_fd,res,strlen(res));
	}

	//7. 关闭资源
	close(client_fd);
	close(server_fd);
    return 0;
}
```



##### 6、tcp的连接过程（3次握手，4次挥手）

（1）概念

TCP（Transmission Control Protocol，传输控制协议）是一种**面向连接的、可靠的、基于字节流**的传输层通信协议。在TCP/IP模型中，TCP提供了稳定、有序且无差错的数据传输。为了保证数据传输的可靠性，TCP使用了三次握手（three-way handshake）机制来建立一个连接，以及四次挥手（four-way handshake）机制来终止一个连接

（2）图示





![image-20240429234910526](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240429234917.png)

![image-20240429235250534](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240429235250.png)

（3）三次握手

- 作用：在通信两端之间建立一个可靠的连接通道，连接建立后双方就可以进行数据通信。

- 简单版

  可以理解为两个人Client和Server打电话为了确保都能听到而进行正式讲话前的测试。

  - **Client**：喂喂喂，听得到不
  - ​                                                                               我听到了，你听到我说话不？：**Server**
  - **Client**：听得到。我给你说个事儿.....     

  经过以上三个步骤可以确认双方都在线，可以开始说正事了（发数据）

- 正式版

  - 第一次握手：客户端发送tcp报文，并将**syn置于1**，**初始序列号X**。syn用于表示该次报文是用于连接使用。
  - 第二次握手：服务器接受后发送连接确认**(Syn=1,ACK=X+1,Seq=Y)**报文,并给定服务器序列号Y
  - 第三次握手：客户端收到确认报文后，也发送一个服务器确认报文**（ACK=Y+1）**，也就是将服务器序列号置为**Y+1**，该报文syn不为1，避免认为是第一步的连接报文。

- tips：

  - **Y+1和X+2**就是后续发送数据的序列号。同时序列号大小跟发送数据的字节量有关。例如：建立链接后，客户端发送了100个字节的数据。假设连接之前序列号就是1（客户端的序列号），发送一个字节序列号就要加1，请问，发送100个字节数据之后，下一次客户端发送数据的序列号是多少？103
  - 序列号本身是一个32位的数字。

（4）四次挥手

- tcp连接结束正常过程会经历四次报文的确认，双方才会正确的关闭链接。

- 简单版

  可以理解为两个人Client和Server电话打完为了确保双方话都说完了而进行的结束测试。

  - 1.**Client**：我这边说完了，你说完了吗？
  - 2  （Client聆听中）                                             你讲完了？等等，我还有最后几句话：**Server**

  - 3                                                                                                        我讲完了，挂了阿：**Server**

  - 4.**Client**:要得。挂了。

- 正式版：

  - 第一次挥手:当某一端A发完数据后，想要关闭连接就发送一个FIN报文给对方B，表示我没有数据发送了，但端A可以继续接受数据。并端A进入最终等待1状态（**FIN_wait 1**）
  - 第二次挥手：当端B接收到FIN报文后会立即发一个 ACK报文给A，表示收到，但我数据还没发完。端B进入**CLOSE_WAIT**状态（等待关闭）,端A收到ACK后，转为最终等待2（FIN_WAIT2）状态。
  - 第三次挥手：当端B数据发送完毕后，也会发送一个FIN报文给端A，表示数据已经发送完毕。端B进入最后确认（LAST_ACK）状态，端A进入TIME_WAIT状态
  - 第四次挥手：当A收到B发 的ack报文后，会发送最终ack报文给端B，在一定时间（2MSL：2次数据最大生存时间）后，没有意外端A会关闭连接，端B收到最终报文后也会关闭连接,进入CLOSED状态。那么整个tcp链接就结束了。

- **注意**：但有一点，如果端B没有收到最终的ACK，它会重传FIN报文，而在TIME_WAIT状态的主机A就可以捕获这个重传的FIN段，并再次发送ACK确认。

- 流程

  - 从报文角度上解析
    - 客户端先发一个FIN报文给服务器端（表示客户端数据发送完毕），服务器接受之后立即发送一个确认报文给客户端（表示我已接受，当我这边数据发送完毕时，还会发送报文）。当服务器数据发送完毕后发送一个结束报文（FIN=1）给客户端（表示数据已经发送完毕）。客户端接受服务器的fin报文后会发送最终确认报文给服务器。服务器接受报文后就会关闭。而客户端在等待一段时间后，没有新的报文接受就会自动关闭。

  - 从状态的角度解析流程
    - 客户端发送结束报文后进入FIN_WAIT1状态。服务器接受fin报文后进行close-wait状态并发送确认报文。
    - 客户端接受服务器确认报文后进入FIN_WAIT2状态。
    - 服务器发送FIN报文后服务器进入（LAST_ACK）状态。
    - 客户端接受fin报文后并发送最终确认报文给服务器，同时客户端进入时间等待阶段（TIME_WAIT）状态。
    - 服务器接受到最终报文后进入closed状态，即关闭了。
    - 客户端在等待一段时间之后自动进入closed状态。




##### 7、练习

```c
1. 利用网络编程实现网络mini版ATM。分为客户端和网络端。详细要求如下：
   - 客户端需要用户连接服务器后输入卡号来进行登录。正确的卡号和密码保存在服务器的全局银行卡结构体数组中，服务器接受客户端发来的卡号数据后进行判断，如果错误就提示卡号错误（客户端可以重新输入），如果正确则发送数据给客户端正确，客户端就输入密码发送给服务器。服务器接受后判断密码是否正确，正确后发送登录成功给用户。
  - 服务器需要保存某张银行卡登录成功的日志记录.记录保存在log.txt 中，格式如下：
    62220345 LOGIN 2024年04月29日 17:16:13 
```



#### 四、udp编程

##### 1、udp协议

（1）协议概念

**UDP**（用户数据报协议，User Datagram Protocol）是一个简单的网络通信协议，属于互联网协议簇中的一部分。与TCP（传输控制协议）相比，UDP是一种无连接的协议，这意味着在数据发送之前，发送者和接收者之间不需要建立连接，也就意味着当我们使用udp协议进行传输数据时，就没有类似tcp链接的机制，无法保证数据的传输准确性和可达性。即**有可能会丢失数据**。

**udp**同**tcp**一样，作用于传输层，针对两个设备或程序提供端到端之间的数据通信。在实际网路编程中是二选一。

（2）udp协议特点

- 无连接：发送数据之前没有跟对方的一个连接过程。即不管另一端的状态，数据直接发
- 不可靠：发送的数据不会管另一方是否正常，也不会有错误检测，数据丢失重发等机制。
- 高效：没有tcp等链接过程的开销，以及数据报文的空间开销较小，发送效率很高
- 应用：特别适合实时性的场景。比如直播、视频通话、语音通话等。



##### 2、udp编程流程

udp编程也是跟tcp一样，分为客户端和服务器端两个部分，大致过程和tcp编程是类似的，具体如下图所示：

![image-20240505201922413](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240505201922.png)

（1）客户端过程

- 通过socket创建一个套接字
- 利用`sendto`函数声明要发送的数据以及要接受数据的服务器端信息
- 如果需要接受数据，调用`recvfrom`来接受服务器端发来的数据，一样在`recvfrom`中声明数据的来源是谁。
- 不需要发送时关闭客户端套接字

（2）服务器端过程

- 通过socket创建一个套接字
- 通过bind来绑定一个端口。
- 通过调用recvfrom可以来接受客户端发来的数据。
- 可以调用sendto 来将数据发送给指定的客户端。
- 不需要发送和接受数据后关闭套接字

##### 3、udp相关函数

以下函数皆包含在于`sys/socket.h`头文件中。

（1）sendto

- 概念

  `sendto` 函数用于UDP协议的套接字**发送数据**。它是一个用于无连接的数据发送的系统调用，可将数据发送至指定的目标地址。

- 语法

  ```c
  ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                 const struct sockaddr *dest_addr, socklen_t addrlen);
  ```

- 参数

  - `sockfd`：发送数据的套接字文件描述符。
  - `buf`：指向待发送数据的缓冲区的指针。
  - `len`：缓冲区中数据的字节长度。
  - `flags`：设置调用执行方式的标志位，通常设置为0。
  - `dest_addr`：指向包含目的地地址的结构体的指针,通常结构体类型为`sockaddr`。
  - `addrlen`：目的地地址结构体的大小。

- 返回值

  - 返回已发送的字节数，失败时返回-1，并设置errno以指示错误。

（2）recvfrom

- 概念

  `recvfrom` 函数用于UDP协议的套接字**接收数据**。它可以从套接字中接收数据，并获取数据发送方的地址

- 语法

  ```c
  ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                   struct sockaddr *src_addr, socklen_t *addrlen);
  ```

- 参数

  - `sockfd`：接收数据的套接字文件描述符。
  - `buf`：指向用于接收数据的缓冲区的指针。
  - `len`：缓冲区的大小，以字节为单位。
  - `flags`：设置调用执行方式的标志位，通常设置为0，表示使用默认的方式来发送，意味着会至少接受一个字节，不然会阻塞程序执行，直到接受到数据。
  - `src_addr`：（可选）指向存储源地址的结构体的指针。
  - `addrlen`：（可选）指向源地址结构体大小的指针。如果不关心源地址，可以分别将src_addr和addrlen设置为NULL

- 返回值

  - 返回接收到的字节数，如果连接已经关闭，返回0，失败时返回-1，并设置errno以指示错误

##### 4、udp编程实例

进行一次互相数据发送和接受的基本使用例子：

（1）客户端

```c
#include <arpa/inet.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
int main() {
  // 1.socket
  int client_fd = socket(AF_INET, SOCK_DGRAM, 0);
  if (client_fd < 0) {
    perror("socket udp()");
    exit(0);
  }
  // 2.设置服务器信息结构体
  struct sockaddr_in server;
  server.sin_family = AF_INET;
  server.sin_port = htons(8099);
  server.sin_addr.s_addr = inet_addr("127.0.0.1");
  // 3 使用sendto
	int writecount;
	//3.1 发送数据
    char data[50] ="";
	puts("请输入发送给服务器的数据");
	scanf(" %49s",data);
    if ((writecount = sendto(client_fd, data, sizeof(data), 0,
                            (struct sockaddr *)&server, sizeof(server))) < 0) {
      perror("sendto()");
      exit(0);
    }
    printf("给服务器发送的数据为:%s\n", data);
  }
  // 4.关闭资源
  close(client_fd);
  return 0;
}
```

（2）服务器端

```c
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
int main(){
	//1.socket
	int server_fd = socket(AF_INET,SOCK_DGRAM,0);
	if(server_fd <0){
		perror("socket()");
		exit(1);
	}
	//2设置服务器的信息
	struct sockaddr_in server;
	server.sin_family = AF_INET;
	server.sin_port = htons(8099);
	server.sin_addr.s_addr = INADDR_ANY;
	//2 bind
	if(bind(server_fd,(struct sockaddr *)&server,sizeof(server))<0){
		perror("bind()");
		exit(1);
	}
	//设置接受客户端信息的结构体
	struct sockaddr_in client;
	socklen_t  len =sizeof(client); 
	//3.recvfrom 
	int readcount; 
	char data[60]="";
	puts("服务器8099已启动，等待接受数据");
	if((readcount =recvfrom(server_fd,data,sizeof(data)-1,0,(struct sockaddr *)&client,&len))<0){
		perror("recvfrom");
		exit(-1);
	}
	data[readcount]='\0';
	printf("udp服务器接受的数据为%s\n",data);
    
	close(server_fd);
	puts("服务器已关闭");
    return 0;
}
```

##### 5、和tcp的区别

UDP和tcp都是在传输层用于实现端和端之间的数据通信，主要有以下区别：

（1）连接性：

- tcp：**面向连接的协议**，这意味着在数据传输开始之前，必须首先建立连接
- udp：**无连接**的协议，它不需要在数据传输前建立连接，数据包（称为数据报）可以随时发送到另一个设备

（2）可靠性：

- tcp：**TCP** 提供可靠的服务，它确保数据正确无误地从源传输到目标
- udp：**UDP** 不保证数据的可靠传输，没有建立机制来确保数据包的顺序或检测丢失的数据包，也没有重传机制

（3）效率方面：

- tcp：**TCP** 由于其重传、错误检测和顺序保证机制，相对于UDP来说通常**速度较慢**
- udp：**UDP** 由于缺乏复杂的错误检查和响应机制，使得它在网络通信中有更少的延迟

（4）数据流控制

- tcp：提供流量控制和拥塞控制机制，这有助于网络在高负载时维持稳定性
- udp：则没有内建的流控制或拥塞控制，发送方的数据发送速率不会根据网络情况自动调整

（5）应用场景：

- tcp：通常用于需要高可靠性的应用，如网页浏览、文件传输、电子邮件等。
- udp：通常用于流媒体视频或音频传输、在线游戏、广播通信等场景，要求实时性较高。实际会配合rtp等应用层协议一起使用，保证实时性的同时兼顾数据的顺序和丢失重发机制。



#### 五、通信的过程

（1）数据的传输过程

<img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/ruishaojun/20231226164102.png" alt="image-20231127165123114" style="zoom: 50%;" />

（2）报文举例

![image-20240506010649321](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240506010649.png)

- 序列号：记录发送数据的序号。比如第一字节的序号为1，第101个字节的序号为101。序号都是32位的
- 确认号：接受对方数据的序号，序号本身是32位 





#### 六、补充

##### 1. 端口号

- 概念：端口号是操作系统为了管理各个应用程序和外网进行数据通信的机制。如果一个程序需要访问网络，那么该程序就必须要绑定一个端口号，才能和外界进行数据交互。
- 端口号本质上是一个数字，是操作系统已启动就会开启。每个端口号都可以为一个应用程序提供网络通信的数据通道。
- 范围：1~65535. 尽量网络编程使用：1000及以上，建议特殊数字，一般程序不会用





#### 七、并发服务器实现

- 概念：并发服务器是指能够同时处理多个客户端连接的服务器（借助多线程）
- 流程

**客户端：**

1. 调用socket()创建一个套接字，并指定ip地址和使用协议，得到一个套接字描述符
2. 调用Connect()尝试连接一个服务器
3. 链接成功之后使用read()或write()进行接受服务器返回的数据或发送数据给服务器
4. 不需要链接之后调用close()关闭套接字，释放套接字所占用的资源。

**服务器端**：

1. 调用socket()创建一个套接字，并指定ip地址和使用协议，得到一个套接字描述符
2. 调用bind()绑定一个端口号
3. 调用listen用于监听绑定的端口
4. 利用while循环调用accept来接受某个客户端的链接，连接成功后创建一个线程来处理该客户端的数据处理。这一步重复执行
5. 不需要链接之后调用close()关闭套接字，释放套接字所占用的资源。





#### 八、群聊服务器实现

- 目的：可以多个客户端连接进服务器，并可以发消息。当其中一个客户端发消息时，其他客户端可以接受该客户发来的消息。
- 思路：
  - 服务器没接收一个客户端连接时，将客户端结构体保存到数组中，定义一个函数，函数用于遍历结构体数组，依次的发送数据。该函数就是用于群发功能。每个客户端发送数据时就调用该群发函数，将昵称、时间、群发信息发送给群发函数并进行群发。
  - 客户端：需要开启一个新的线程用于接受群发的信息。main函数用于发送信息给客户端。
