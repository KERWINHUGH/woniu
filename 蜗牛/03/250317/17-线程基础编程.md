## 线程基础编程

### 课程目标

1. 了解线程的定义及重要性。

3. 学习线程的基本使用方法。

4. 理解线程同步与通信。

5. 掌握多线程编程

   

### 课程实验

1. 创建/退出/分离/阻塞线程实验

2. 多线程实战

3. 条件变量实现线程同步

4. 互斥锁应用实验

   

### 课堂引入

> 早期的计算机只能执行一个任务，一旦任务完成，计算机就会等待下一个任务。这种模型效率低下，无 法充分利用计算机的性能。
>
> 随着计算机技术的发展，操作系统开始支持多进程模型，即同时执行多个任务。每个任务被称为一个进 程，每个进程都有自己的内存空间和资源。这种模型提高了计算机的并发执行能力，但仍然存在资源共 享的问题（进程间通信开销很大（学习过程中会刻意植入概念）。 
>
> 为了进一步提高计算机的并发执行能力以及资源更高效利用，多线程模型被引入。每个进程可以拥有多个线程，这些线程共 享进程的内存空间和资源。多线程模型可以更好地利用计算机的资源，提高程序的执行效率

![image-20240506150157484](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240506150157.png)

8核心：指的一个完整的cpu芯片有8个cpu核心，每个核心可以执行一个程序的代码。

16线程：一个完整cpu最多有16个线程同时在执行。每个cpu核心可以同时处理两个线程。以c语言程序为例。一个线程可以执行一个c语言程序。

**总结：一个cpu同一时间可以执行很多个线程，每个线程都可以执行代码**

### 授课进程

#### 一、线程概念

##### 1、什么是线程

（1）官方定义

线程是操作系统能够**进行运算调度的最小单位**，它被**包含在进程**之中，是**进程中实际运行工作**的单位。每个线程都是进程的一部分，包含**在进程的地址空间**内，**可以利用**进程所拥有的**资源**

理解线程：为计算机种实际执行工作的最小单位。

（2）线程和进程之间的关系

- **包含**：**进程**是系统中资源分配的最小单元，具有独立的地址空间。而**线程**是执行（cpu调度）的最小单元，**同一进程中的多个线程共享进程的资源**，如内存和文件。
- **通信**：进程间通信需要特定的IPC机制，并且进程间相互独立。而**线程之间可以直接通信**，因为它们共享同一个进程内的内存地址空间（需要满足这几个线程是同一进程的）。
- **开销**：创建新进程的资源和时间开销相对较大。线程相对轻量，创建和切换线程的开销小于进程。
- **调度**：操作系统独立调度进程。操作系统在进程内部调度线程，使得在执行任务时能并行处理，提高执行效率

**一个进程里可以包含多个线程，同一个进程里的不同线程之间可以共享资源**

（3）如何理解线程

工厂例子：一个工厂里有很多工人，工人们共享同一个工厂里的资源来进行工作，而每个工人可以做不同的工作，比如一个工人负责零件制造生产线，另一个工人则负责零件焊接，并且多个工人可以同时进行工作。那么最终多个工人的协同工作可以生产一个产品。

这里面工厂就好比进程，一个工人就好比线程。进程里可以包含多个线程，而每个线程都共享同一个进程里的资源，每个线程都可以负责一个任务，并且可以同时进行。比如qq音乐用一个进程来执行，那么一个线程可以用来加载桌面应用界面，一个线程用于进行数据获取，一个线程用于进行音频的播放和暂停等。

![image-20240319102308162](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240319102308.png)

![image-20240319102152253](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240319102152.png)

##### 2、线程的总结

- 线程：线程是计算机中执行指令（运算调度:执行代码）的最小单位，线程是存在于正在运行的程序（进程）之中。每个程序至少有一个线程（默认线程（主线程），操作系统自动创建），一个进程可以有多个线程。比如运行的qq音乐就是一个进程。里面有多个线程负责不同的功能，一个负责播放，一个负责网络数据获取。并且两个线程都可以使用进程里的资源。并且负责网络数据的线程出问题，播放线程也可以继续播放。但是如果进程结束了（关闭qq音乐），其中的所有线程也会结束。

  - **一个进程里可以包含多个线程。**
  - **每个线程都可以执行指令（代码）**
  - **不同线程可以共享进程里的资源**
  - **一个线程异常，其他线程可以继续执行。**

  比如执行a.out就相当于操作系统新建一个进程并自动创建一个线程（主线程）来执行main函数代码。

- 特点
  - 独立性：同一个程序里的不同线程之间是相互独立的，即一个线程的结束或崩溃不会影响到`其他线程的执行`。
  - 数据共享：同一个程序里的所有线程都可以直接使用该程序里的资源。比如全局变量等。
  - 并行处理：同一个程序，如果有多个线程，那么这几个线程是同时执行的（具体谁先执行，是由cpu和操作系统调度算法决定）

##### 3、线程的好处

（1）资源消耗更少

- **内存占用**：线程之间共享进程的内存空间，包括代码段、数据段和打开的文件等。这意味着创建一个新线程所需的内存远少于创建一个新进程，因为后者需要为其分配独立的内存空间。
- **创建和销毁开销**：线程的创建和销毁比进程更快、更节省资源，因为进程需要进行更多的内存和资源分配。

（2）数据共享、通信更方便

- **数据共享**：由于线程共享同一进程的内存空间，它们之间的数据共享非常方便，不需要特殊的IPC（进程间通信）机制。这使得线程间的数据交换和状态同步更加高效。
- **通信成本**：线程间的通信成本远低于进程间通信。进程间通信需要操作系统介入，进行上下文切换，而线程间可以直接通过读写共享内存来通信。

（3）提高程序响应性

- **用户界面响应**：在用户界面（UI）密集的应用程序中，多线程可以在一个线程中处理用户交互，而在另一个线程中执行后台任务，从而保持应用程序的响应性。
- **并发操作**：多线程允许程序在等待某些操作（如I/O操作）完成时继续执行其他任务，从而提高程序的整体效率和用户体验。

（4）更高的效率

- **利用多核处理器**：在多核处理器上，多线程能够更有效地利用计算资源。通过将不同线程分配到不同的处理器核心上，可以实现真正的并行计算，从而提高程序的执行效率。

（5）程序设计模型简化

- **简化复杂操作**：对于某些问题，使用多线程可以简化程序设计。例如，在网络服务器或并发处理应用中，为每个客户端连接或任务分配一个线程可以简化编程模型，使得代码更容易理解和维护。

##### 4、多线程和多进程

（1）多进程编程

多进程编程是指一个应用程序使用两个或多个并行运行的进程来执行任务。每个进程在操作系统中作为一个独立的实体存在，拥有自己的地址空间、系统资源和数据。进程间通常通过进程间通信（IPC）机制（如管道、消息队列、信号量等）来交换信息。

**特点分析**：

- **隔离性**：每个进程有自己的内存和资源，一个进程的崩溃不会直接影响到其他进程。
- **资源需求**：创建进程比线程更消耗资源，因为每个进程需要独立的内存和系统资源。
- **通信成本**：进程间的通信成本较高，因为它们在不同的内存空间中，需要操作系统介入来实现数据交换。

（2）多线程编程

多线程编程是指在单个应用程序内部创建和管理两个或多个并行运行的线程。线程是进程的执行单元，它们共享父进程的地址空间和资源，如内存和文件句柄等。虽然线程共享资源，但每个线程有自己的执行堆栈和程序计数器。

**特点分析**：

- **资源共享**：线程间自然共享进程资源，使得数据共享和通信更方便。
- **开销较小**：相比进程，创建和管理线程的开销小，因为它们共享许多资源。
- **同步问题**：由于资源共享，线程间的同步和并发控制变得复杂，需要使用互斥锁、读写锁、条件变量等机制来避免冲突和竞态条件。

（3）两个的应用场景和区别

对比

- **隔离性 vs. 效率**：多进程提供更好的隔离性，但以较高的资源需求和通信成本为代价；而多线程提供了更高的资源效率，但需要更小心地管理资源共享和同步问题。
- **安全性 vs. 速度**：多进程由于隔离性较高，通常被认为更安全，适合需要隔离不同任务的场景；多线程则因其轻量和快速响应的特性，适合对性能要求高的场景。

应用场景

- 多进程:

  - 浏览器每个标签页都是一个进程
  - 操作系统中的服务和守护进程通常是独立的进程，以确保稳定性。
  - 手机系统的每个app应用都是一个进程

- 多线程

  - 各种gui应用（界面应用，比如qq音乐）

  - 各种游戏等（比如英雄联盟等）

    - 使用多线程可以减少游戏的延迟，提高响应速度，这对于需要实时交互的游戏尤为重要。例如，在英雄联盟这种需要快速响应玩家操作的游戏中，一个线程可能专门用于处理用户的输入，确保游戏控制的反应速度，而不会因为渲染或网络延迟而受到影响。
      - **渲染线程**：负责绘制游戏画面到屏幕上。
      - **逻辑线程**：处理游戏逻辑，如玩家输入、AI 决策等。
      - **声音线程**：用于处理音频的播放。
      - **网络线程**：管理玩家之间的网络通信或与服务器的数据同步。

    - 然而，这并不排除游戏在某些情况下可能使用多进程，例如游戏客户端和配套的聊天或更新服务可能是运行在单独进程中的。但核心游戏循环和功能性的部分，如图形渲染和游戏逻辑处理，通常是在同一个进程中的多个线程来完成的

  - 数据库（mysql，sql server）

#### 二、线程的使用和管理(c99)

如果要使用线程需要引入对应的头文件。同时后续在用gcc命令时需要加上`-lpthread`参数来表示链接线程函数库，不然会报一下错误，而无法使用

```c
#include <pthread.h>
gcc 文件名 -lpthread
```

![image-20240319155129530](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240319155129.png)

##### 1、创建线程

（1）基本语法

```c
int pthread_create(pthread_t *thread,
 const pthread_attr_t *attr,
 void* (*start_routine)(void *),
 void *arg);
```

- 参数
  - thread: 指向线程标识符(ID)指针。 
  - attr: 线程的属性和设置堆栈的大小 分离属性:线程结束后，自己归回空间 ，非分离属性:线程结束后，由创建者去归还空间 一般填写NULL 如果想设置后续有固定的函数 
  - start_routine: 线程运行函数起始地址，一旦线程被创建就会执行 
  - arg: 给线程函数传参使用，一般用于线程间通信使用，如果不进行传参填写NULL
- 返回值
  - 如果成功返回 0 
  - 如果失败返回错误码 strerror()

（2）函数效果

调用pthread_create函数时，**操作系统会为运行该代码的进程创建一个线程并立即执行传入的函数：start_routine，并将第四个参数作为实际参数传递给执行的函数(start_routine)**

（3）使用注意

- 在线程被创建之后会**立马执行参数中指针指向的函数**。
- 创建多个线程之后，这几个线程(包括主线程)之间的执行顺序是受操作系统来决定（调度算法）
- 在线程运行过程之中，进程结束时资源释放后，线程没有办法执行了 
- 在多线程中，线程中尽量不调用影响整个进程的函数接口，线程本身安全性不高，一个线程崩溃会 造成进程的崩溃。 （下面的线程加了exit(0)后也会结束主线程） 
- 线程中通信方式2种 （全局变量）和（参数arg）。不过在使用全局变量时，如果一个线程对其进行改变，所有线程访问的值都是改变后的值

（3）基本使用例子

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void* thread_func(void *arg) {
    printf("thread_func is running\n");
}
int main() {
    //创建线程
    pthread_t tid;
    pthread_create(&tid, NULL, thread_func, NULL);
    //等待线程结束
    pthread_join(tid, NULL);
    return 0;
}
```

**注意**：里面的`pthread_join`用于阻塞等待一个线程的结束

（4）其他说明

- `pthread_t`是POSIX线程（Pthreads）库中定义的一个数据类型，用于唯一标识一个线程。它不是C语言的基本数据类型（如`int`、`float`等）。`pthread_t`通常在使用Pthreads库创建和管理线程时作为线程标识符使用

##### 2、结束一个线程：pthread_exit

用于退出一个线程。当一个线程调用此函数时，它会结束自己的执行，但不会影响其他线程。

（1）基本语法

```c
void pthread_exit(void *retval);
```

- 参数
  -  retval:线程结束时的状态，如果不传递填写NULL。其他线程可以通过pthread_join时会返回此状态

（2）和exit的区别

- `pthread_exit`是线程级的退出，而`exit`是进程级的退出。使用`pthread_exit`可以让线程清理后结束运行，而不会影响其他线程或进程；而使用`exit`则会结束所有线程并关闭整个程序。通常在多线程程序中，当你只需要结束一个线程的时候使用`pthread_exit`，而当你需要结束整个程序时使用`exit`。

（3）注意

- `pthread_exit`仅仅是终止线程的执行；如果其他线程不调用`pthread_join`来等待该线程的结束，并且该线程也没有被设置为分离状态（`pthread_detach`），那么这个线程在退出后其资源仍然会保留（成为僵尸线程），直到这两个条件中的一个被满足，其资源才会被释放

（4）示例代码

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

// int a = 100;
void *myfun(void *arg)
{
    // 线程传参
    int a = *(int *)arg; // 线程传参
    // 输出提示信息
    printf("我是第一个线程\n");
    // 代表线程工作 3 S
    sleep(3); // 代表线程工作 3 S
    // 输出A的值
    printf("子线程获取A的值为%d\n", a);
    // 线程结束
    pthread_exit(NULL);
}
int main(int argc, char *argv[])
{
    // 创建一下线程
    int a = 100;
    pthread_t tid = 0;
    if (pthread_create(&tid, NULL, myfun, &a) != 0)
    {
        printf("创建线程失败了\n");
        return -1;
    }
    printf("线程号为%ld\n", tid);
    printf("主线程获取A的值为%d\n", a);
    if (0 != pthread_join(tid, NULL))
    {
        printf("回收资源失败\n");
        return -1;
    }
    printf("回收成功\n");
    return 0;
}

```



##### 3、等待线程结束：pthread_join

pthread_create调用成功以后，新线程和老线程谁先执行用户是不知道的，这一块取决与操作系统对线 程的调度，如果我们需要等待指定线程结束，需要使用pthread_join函数，这个函数实际上类似于多进 程编程中的waitpid

（1）基本语法

```c
int pthread_join(pthread_t thread, void **retval);
```

- 参数
  - thread: 目标回收的线程号 
  - retval: 线程结束时`pthread-exit`或线程函数通过`return`返回的状态 如果不考虑，则填写NULL
- 返回值
  - 成功：返回0
  - 失败:返回错误码

（3）示例代码

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

// int a = 100;
void *myfun(void *arg)
{
    // 线程传参
    int a = *(int *)arg; // 线程传参
    // 输出提示信息
    printf("我是第一个线程\n");
    // 代表线程工作 3 S
    sleep(3); // 代表线程工作 3 S
    // 输出A的值
    printf("子线程获取A的值为%d\n", a);
    // 线程结束
    exit();
}
int main(int argc, char *argv[])
{
    // 创建一下线程
    int a = 100;
    pthread_t tid = 0;
    if (pthread_create(&tid, NULL, myfun, &a) != 0)
    {
        printf("创建线程失败了\n");
        return -1;
    }
    printf("线程号为%ld\n", tid);
    printf("主线程获取A的值为%d\n", a);
    if (0 != pthread_join(tid, NULL))
    {
        printf("回收资源失败\n");
        return -1;
    }
    printf("回收成功\n");
    return 0;
}
```

##### 4、设置线程分离属性：pthread_detach

（1）基本语法

```c
int pthread_detach(pthread_t thread);`
```

- 功能：设置线程分离属性。将**线程标识为已分离的线程**。当一个分离的线程终止时， **它的资源被自动释放回系统，而不需要另一个线程与终止的线程连接**，也就是说当该线程分离之后，其代码执行完资源就会自动释放
- 参数：thread：目标线程号
- 返回值
  - 成功:返回 0 
  - 失败:返回错误码

##### 5、获取自己的线程号：pthread_self

返回调用线程的ID。这个值与创建该线程的pthread_create调 用中的*thread(线程号)中返回值相同。

（1）基本语法

```c
pthread_t pthread_self();
```

##### 6、申请结束一个线程： pthread_cancel

（1）基础语法

申请结束一个线程 （向线程发送一个取消请求。目标线程是否以及何时对取消请 求做出反应取决于该线程控制的两个属性:状态和类型。）

```c
int pthread_cancel(pthread_t thread)
```

- 参数
  - 需要结束的线程号
- 返回值
  - 成功：0，只能说成功提交了取消请求，不能说取消成功。具体是否取消成功是受线**程自身的取消状态**和**取消类型**属性，以及**线程是否达到了取消点**这些来综合决定的。要确定目标线程是否真正被取消，其他线程需要调用`pthread_join`并检查传出的状态是否为`PTHREAD_CANCELED`
  - 失败:返回非0 的错误代码。情况有可能是一个无效id或线程已终止，或该线程已被设置为不响应取消请求。

（2）注意

- 一般线程什么时候是系统管控的，系统会针对线程的取消机制提供了取消点机制。**取消点**是线程可能检查取消请求并决定是否退出的预定义的程序执行点，例如系统调用或者库函数（比如read、write函数等）
- 如果要不响应取消可以使用`pthread_setcancelstate`来设置状态。具体见下

（3）线程取消机制设置

- 设置是否取消：pthread_setcancelstate

  - 语法

  ```c
  int pthread_setcancelstate(int state, int *oldstate);
  ```

  参数

  1. state：指定新的取消状态，接受两个值：
     - `PTHREAD_CANCEL_ENABLE`：设置线程为可取消状态，这是默认设置。线程可以在任何取消点（以及如果设置为异步取消类型，那么几乎在任何执行点）响应取消请求。
     - `PTHREAD_CANCEL_DISABLE`：设置线程为不可取消状态，即忽略取消请求。线程不会响应取消请求，直到取消状态被更改为 `PTHREAD_CANCEL_ENABLE`。
  2. oldstate
     - 一个指向 `int` 的指针，用于存储调用此函数之前的取消状态。如果对之前的状态不感兴趣，可以传递 `NULL`。

  - 例子

  ```c
  void *thread_routine(void *arg) {
      int oldstate;
  
      // 禁用线程取消
      pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &oldstate);
      
      // ... 线程的不可取消操作 ...
  
      // 恢复线程到之前的取消状态
      pthread_setcancelstate(oldstate, NULL);
  
      return NULL;
  }
  
  int main(int argc, char *argv[]) {
      pthread_t thread;
      pthread_create(&thread, NULL, thread_routine, NULL);
  
      // ... 其他操作 ...
  
      pthread_join(thread, NULL);
      return 0;
  }
  ```

  **注意**：在上面的代码片段中，我们首先调用 `pthread_setcancelstate`，将线程的取消状态设置为 `PTHREAD_CANCEL_DISABLE`，这意味着任何取消请求都会被线程忽略。在执行完不可取消的操作后，可以将取消状态恢复到之前的状态（例如允许取消），这样线程在后续执行中就可以响应取消请求了。

  **注意**：禁用线程取消时要谨慎，因为这可能会防止程序正常关闭，尤其是在需要对资源进行清理的时候。因此，只在确实需要的时候，且知道可能的后果的情况下，才应该禁用线程取消。通常，不要永久禁用线程取消，而是只在临界区或执行不应该被中断的操作时临时禁用。在操作完成后，应该恢复到可取消的状态

- 设置线程取消类型

  - 基础语法

  ```c
  pthread_setcanceltype(int type, int *oldtype);
  ```

  - 功能：这个函数可以设置线程取消的行为方式
  - 参数
    - type参数可以是PTHREAD_CANCEL_DEFERRED（延迟取消，只在取消点检查取消请求）或PTHREAD_CANCEL_ASYNCHRONOUS（允许线程在任何非取消点立即被取消）
    - oldtype:和pthread_setcancelstate一样，如果oldtype不是NULL，之前的取消类型会被存储在oldtype指向的位置

#### 三、多线程实战

##### 1、多线程编程概念

多线程编程是一种编程范式，它允许同时执行多个线程，以进行并行处理和提高效率。

##### 2、示例：并发服务器的实现

### 课程小结

### 随堂作业

1. 利用两个线程完成文件读写的操作(方便引入同步和互斥)

   ```c
   //引入头文件
   #include <stdio.h>
   #include <pthread.h>
   //定义线程函数
   void readFile(char [] filename);
   void writeFile(char [] filename);
   void readFile(char [] filename){
       //显示读取操作线程id
       printf("当前读操作线程：%ld",pthread_self());
       //线程读取文件
       File *file = fopen(filename, "r");
       //读取内容
       char buffer[1024];
       while(fgets(buffer, 1024, file) != NULL){
           printf("%s", buffer);
       }
       printf("\n读取完毕");
       fclose(file);
       pthread_exit(0);
   }
   
   void writeFile(char [] filename){
       //显示写操作线程id
       printf("当前写操作线程：%ld",pthread_self());
       //线程写入文件
       File *file = fopen(filename, "w");
       //写入内容
       fprintf(file,"hello world\n");
       fclose(file);
       printf("\n写入完毕");
       pthread_exit(0);
   }
   //测试
   int main (){
       pthread_t read, write;
       //创建两个线程
       
       if(pthread_create(&write,NULL,(void *)writeFile,"data.txt")!=0){
           printf("创建写操作线程失败");
       }
       if(pthread_create(&read,NULL,(void *)readFile,"data.txt")!=0){
           printf("创建读操作线程失败");
       }
       //等待线程结束
       
       pthread_join(write,NULL);
       pthread_join(read,NULL);
       return 0;
   }
   ```

2. 利用同步和互斥来解决以下问题；定义三个线程，分别可以打印A、B、C。利用同步和互斥来实现最终打印BCABCABCA

   



