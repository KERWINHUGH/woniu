int a = 10;
int *p = &a;        // "&" 在这里称为取地址

& ---- 引用，取址，位与
&& ---- 逻辑与

&a ---- 取地址
a & b ---- 位与
a && b ---- 逻辑与

引用的特点：
1. 引用只是别名(不是变量，也不是地址，不占用内存空间)

int a = 10;
int &ra = a;        // ra 是 a 的别名，ra 不是变量，也不是地址，不占用内存空间
cout << &ra << endl;
cout << &a << endl;
=================================================================================================================
int &ra;    // 这样写是错误的，引用必须初始化
ra = a;

const int a = 10;
const int x;    // 这样写是错误的，const 修饰的变量必须初始化
x = 20;

2. 引用在声明的时候必须要初始化
int &ra = a;

3. 引用一旦初始化，就不能更改引用的对象
int a = 10;
int b = 20;
int &ra = a;
ra = b;    // 这里是更改引用的对象，不是更改引用本身

void swap(int a, int b) {
    int tmp = a;
    a = b;
    b = tmp;
}

int main() {
    int a = 10;
    int b = 20;
    swap(a, b);
    return 0; 
}

函数默认参数(缺省参数)：
1. 默认参数必须从右往左依次设置
2. 默认参数可以是常量、全局变量、静态变量、引用
3. 默认参数只能在函数声明中设置，不能在函数定义中设置
4. 默认参数只能设置一次，不能多次设置
5. 默认参数可以不设置，也可以设置部分参数


1. C++支持函数默认参数
2. C++默认参数的形式如下：
    返回值类型 函数名(参数1 = 默认值1, 参数2 = 默认值2, ...) {
        // 函数体
    }
    void func1(int x = 99) {
        cout << "This is Func, x = " << x << endl;
    }
    函数调用：
    func1();       // 输出：This is Func, x = 99
    func1(100);    // 输出：This is Func, x = 100
=================================================================================================================
    void func1(int x, int y = 99) {
        cout << "This is Func, x = " << x << endl;
        cout << "This is Func, y = " << y << endl;
    }
    函数调用：
    func1(100);    
    // 输出：This is Func, x = 100
    // 输出：This is Func, y = 99
    func1(100, 200);    
    // 输出：This is Func, x = 100
    // 输出：This is Func, y = 200
=================================================================================================================
    注意：下面的函数用法是错误的,因为默认参数必须从右往左依次设置
    void func1(int x = 99, int y) {
        cout << "This is Func, x = " << x << endl;
        cout << "This is Func, y = " << y << endl;
    }
=================================================================================================================
    void func1(int x = 99, int y = 188) {
        cout << "This is Func, x = " << x << endl;
        cout << "This is Func, y = " << y << endl;
    }
    函数调用：
    func1();       
    // 输出：This is Func, x = 99
    // 输出：This is Func, y = 188
    func1(100);    
    // 输出：This is Func, x = 100
    // 输出：This is Func, y = 188
    func1(100, 200);    
    // 输出：This is Func, x = 100
    // 输出：This is Func, y = 200

    解释如下：  
        1. 如果调用func1函数时没有传递参数，则使用默认值99。
        2. 如果调用func1函数时传递了参数，则使用传递的参数。
        3. 函数调用时，可以只传递部分参数，未传递的参数将使用默认值。
3. C++默认参数的意义在于，可以减少函数调用的复杂度，提高代码的可读性和可维护性。
4. C++默认参数的使用需要注意以下几点：
    1. 默认参数必须从右往左依次设置
    2. 默认参数只能在函数声明中设置，不能在函数定义中设置
    3. 默认参数只能设置一次，不能多次设置
    4. 默认参数可以不设置，也可以设置部分参数

函数重载：
    1. 函数重载是指在同一个作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数。
    2. 重载函数通常用于实现功能类似但参数类型或个数不同的函数，通过不同的参数类型，可以让编译器根据不同的参数类型自动选择对应的函数进行调用。
    3. 函数重载的条件：
        1> 相同的作用域
        2> 函数名相同
        3> 参数列表不同
            1) 参数个数不同
            2) 参数类型不同(参数顺序不同)
        注意⚠️: 
            1) 函数返回值类型不同不足以成为函数重载的条件(函数的返回值类型可以相同也可以不同)
            2) 函数重载和默认参数一起使用，需要额外注意二义性问题的产生。

函数重载和默认参数一起使用产生二义性问题：
    1. 当函数重载和默认参数一起使用时，可能会产生二义性问题。
    2. 例如：
        void func(int x) {
            cout << "This is Func, x = " << x << endl;
        }
        void func(int x, int y = 99) {
            cout << "This is Func, x = " << x << endl;
            cout << "This is Func, y = " << y << endl;
        }
        函数调用：
        func(100);          // ❌ 错误: 调用时出现二义性
        func(100, 200);     // 输出：This is Func, x = 100


#ifndef MYMODULE_H
#define MYMODULE_H

#include <stdio.h>

#if __cplusplus		// 在C++环境中
extern "C" {
#endif
	void func1();
	int func2(int a,int b);
#if __cplusplus
}
#endif
#endif


lambda表达式：
[](){};
void func() {}

int main() {
    int a = 10;
	[&]() {
		a = 20;
		cout << "a = " << a << endl;
	};
    cout << "a = " << a << endl;
    return 0;
}

auto f = ...;
auto f;     // ❌
f = ...;

auto f = [=](int){
    ...
};