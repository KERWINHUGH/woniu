`C++`默认的成员函数

`C++`编译器对于一个空类,即使程序没定义任何成员,编译器也会添加以下的函数成员:
> 1. 默认构造函数
> 2. 析构函数
> 3. 拷贝构造函数
> 4. 赋值运算符(等号:operator=)
> 5. 取址运算符(operator&)(一对,一个非const的,一个const的)

this指针
    1. 什么是this指针:
        在C++中,`this`指针是一种特殊的指针,它指向当前对象本身。其作用就是指向静态成员函数无法使用this指针。
    2. this指针和静态成员
        (1) 静态成员不能使用 this 指针,因为静态成员相当于是共享的,不属于某个对象。
        (2) this只能在成员函数中使用。全局函数,静态函数都不能使用this。
        (3) 静态函数如同静态变量一样,不属于具体的哪一个对象,静态函数表示了整个类范围意义上的信息,而this指针却实实在在的
            对应一个对象,所以this指针当然不能被静态函数使用了,同理,全局函数也一样。
        (4) this指针的使用
            1)在类的非静态成员函数中返回类对象本身的时候,我们可以使用圆点运算符(*this). , 箭头运算符this->
            2) 当我们需要将一个对象作为整体引用而不是引用对象的一个成员时,可以在该函数返回对调用该类对象的引用(*this)。
            3) 另外我们也可以返回关于 *this 的引用,这样我们可以像输入输出流那样进行"级联"操作。
            4) 当形参和成员变量同名时,可用this指针来区分
    3. this指针的特性:
        (1) this指针是一个常量指针,它的值不能被修改。
        (2) this指针是什么时候创建的?
            this在成员函数的开始执行前构造的,在成员的执行结束后清除。    
        (3) this指针如何传递给类中函数的?this指针又是如何找到类实例后函数的?
            this通过函数第一个参数来传递的。this指针是在调用之前生成的。类在实例化时,只分配类中的变量空间,并没有为函数分配空间。
        (4) this指针只有在成员函数中才有定义
            在获得一个对象后,也不能通过对象使用this指针。我们也无法知道一个对象的this指针的位置(在成员函数里才有this指针的位置)。
            当然,在成员函数里,你是可以知道this指针的位置的(可以&this获得),也可以直接使用的。
    4. 总结:
        (1) c++规定,this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后,它的每个成员函数都含有一个系统自动生成的指针this,
           用以保存这个对象的地址,也就是说虽然我们没有写上this指针,编译器在编译的时候也是会加上。因此this也称为"指向本对象指针",
           this指针并不是对象的一部分,不会影响sizeof(对象)的结果。
        (2) this指针是C++实现封装的一种机制,它将对象和该对象调用的成员函数连接在一起,在外部看来,每一个对象都拥有自己的函数成员。
           一般情况下无需this,而是让系统进行默认设置。this指针永远指向当前对象。       
          
类的构造函数:
    形式：
    类名() {
        // 函数体
    }
    1. 构造函数名和返回值:
        (1) 函数名和类名相同
        (2) 构造函数没有返回值,也不能写void
    2. 构造函数可以重载(可以有0-n个形参)
    3. 构造函数可以有缺省值
    4. 构造函数的作用:
        (1) 初始化该类的成员变量
        (2) 构造函数可以传参
    5. 构造函数的调用方式:
        (1) 创建对象的时候自动调用
        (2) 使用new关键字创建对象的时候自动调用
    6. 构造函数的分类:
        (1) 默认构造函数:注意：如果我们定义了一个无参的构造函数，这个不是默认构造函数，而是自定义的无参构造函数
            1) 无参构造函数
            2) 函数体为空
        (2) 有参构造函数
        (3) 拷贝构造函数
    7. 指定使用默认的构造函数,这里需要使用`default`关键字。
        Info() = default;       // 指定使用默认构造函数, Info() {}
    8. 禁用默认的构造函数,这里需要使用`delete`关键字。
        Info() = delete;        // 禁用默认构造函数, Info() {}

构造函数初始化数据成员：
    1. 直接初始化
    2. 成员初始化列表(参数列初始化)
        1) 效率高，功能强大
        2) 特别是在声明const成员和成员为引用的时候，如果没有直接初始化，那么唯一初始化的方式就是使用成员初始化列表
    3. 构造函数的调用顺序:
        1) 先初始化成员变量
        2) 再执行构造函数的函数体
    4. 构造函数的调用顺序:
        1) 先初始化成员变量
        2) 再执行构造函数的函数体

成员初始化的次序：
    每个成员在构造函数初始化列表中只能指定一次。重复初始化,编译器一般会有提示。
    1. 按照成员变量在类中声明的顺序进行初始化
    2. 与初始化列表中的顺序无关

建议：
    ✧ 如果定义了其他构造函数,也提供一个不带形参的构造函数。

隐式类类型转换:
    1. 除非有明显的理由想要定义隐式转换,否则单形参构造函数应该声明为explicit。将构造函数设置为explicit可以避免错误。
    2. explicit 能防止隐式类型转换的发生。防止从参数类型向该类类型转化。

禁止复制
    ✧ 有些类需要完全禁止复制。例如 iostream 类就不允许复制。延伸：容器内元素不能为 iostream 
    ✧ 为了防止复制,类必须显式声明其复制构造函数为 private。(比如单例模式) 

拷贝构造函数：
    1. 拷贝构造函数又称为复制构造函数,是一种特殊构造函数,只有1个形参,该形参(常用 const&修饰)是对该类类型的引用。
       用于将一个对象复制到新创建的对象中。
    2. 如果没有自定义拷贝构造函数，编译器会为我们生成一个默认的拷贝构造函数。
    3. 拷贝构造函数的调用时机:
        1) 使用类的对象初始化另一个对象
        2) 使用new关键字创建对象的时候自动调用
拷贝构造函数通常用于:
    1. 通过使用一个相同类型的对象来初始化新创建的对象。  // Info info2(info1);
    2. 复制对象把它作为参数传递给函数。     // void Func(Info b) {...}
    3. 复制对象，并从函数返回这个对象。     // Info Func(int b) {...}
    编译系统在我们没有自己定义拷贝构造函数时,会在拷贝对象时调用默认拷贝构造函数,进行的是浅拷贝！即对指针拷贝后会出现
    两个指针指向同一个内存空间。

    什么是浅拷贝：
        1. 成员变量的值直接拷贝
        2. 成员变量的指针直接拷贝
    浅拷贝可能带来的问题：
        两个对象的成员变量的指针指向同一块内存空间,当一个对象的生命周期结束时,会释放该对象的成员变量的指针指向的内存空间,
        当另一个对象的生命周期结束的时候,会释放该对象的成员变量的指针指向的内存空间,导致程序崩溃。  
    解决方案：
        1. 在对含有指针成员的对象进行拷贝时,必须要自己定义拷贝构造函数,使拷贝后的对象指针成员有自己的内存空间,
           即进行深拷贝,这样就避免了内存重复释放发生。
        2. 使用智能指针(智能指针是一个类,它的构造函数会为指针分配内存空间,析构函数会释放指针指向的内存空间)
    深拷贝：
        1. 成员变量的指针指向新的内存空间
        2. 拷贝构造函数的参数是一个const引用,防止修改参数的值。
    
    总结：
        1. 浅拷贝只是对指针的拷贝,拷贝后两个指针指向同一个内存空间,深拷贝不但对指针进行拷贝,而且对指针指向的内容进行拷贝,
           经过深拷贝后的指针是指向两个不同地址的指针。
        2. 浅拷贝带来问题的本质在于析构函数释放多次堆内存,使用智能指针(std::shared_ptr),可以完美解决这个问题。

析构函数:
    形式：
    ~类名() {
        // 函数体
    }
    特点：
    1. 析构函数函数名和构造函数类似，只要在构造函数前添加一个`~`符号即可。
    2. 析构函数没有返回值,也没有参数。
    3. 析构函数不能重载。
    4. 一个类只能有一个析构函数,如果没有定义,编译器会自动生成一个默认的析构函数。
    5. 析构函数的作用: 释放该类的成员变量的资源
    6. 析构函数的调用时机:
        1) 当对象的生命周期结束的时候自动调用   
        2) 当调用delete关键字释放对象的时候自动调用
