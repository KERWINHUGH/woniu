## 目录 

- 数据结构的概念
- 分类
- 顺序结构
- 栈
- 队列
- 链表

#### 课程目标

1. 数据结构的概念
   1. 根据业务数据需求，**自定义**的复杂的数据类型（动态数组、队列（顺序队列，链式队列））
2. 数据结构的作用
   1. 用于管理业务中的数据（增删查改），根据业务数据的特点，选择合适的数据结构：插入快（链表），查询快（数组）。除此以外如果业务数据处理还有其他的特点（先进先出、先进后出等）
   2. 例子
      1. 插入删除快：链式的数据结构
      2. 查询快：线性结构（用的数组：连续空间）
      3. 插入删除快，先进先出：链式队列（队列链表）
      4. 查询快，带有下标，先进后出：线性栈
      5. 查询快，内存灵活：链式的动态数组。
3. 常见数据结构
   1. **表（动态数组）**
      1. **顺序表（线性）**
      2. **单链表（链式）**
   2. 栈（理解：先进后出）
      1. 顺序
      2. 链式
   3. **队列**（先进先出）
      1. **顺序队列**
      2. **链式队列**
   4. 图
   5. 哈希
   6. 树
4. 什么时候用数据结构
   1. 需要管**理项目（产品）业务数据**，当编程语言内置数据类型无法满足。比如需要扩容、内存使用灵活、先进先出等

### 课堂引入

在日常生活中，我们经常会遇到各种需要组织和处理数据的场景：
一张地图可以看作是一个包含城市、道路等信息的数据结构，有助于规划行程。
一家超市的库存管理系统需要存储商品的诸多信息，如价格，数量，生产日期...

**数据存储只有一个目的，即为了方便后期对数据的再利用**
之前学习过c语言的基本数据类型，也学习了数组指针相关知识，基于这些知识完成了一些简单的
demo,但是想要处理上述类似的需求就显得力不从心了。
在真实的项目开发中，我们要处理的数据可不像之前那么的简洁，这个时候就需要考虑到操作数据
的效率了，因为我们要处理更大规模的数据，同时还要关注代码的模块化及代码复用的问题，这些
都需要我们深入的掌握数据结构的相关知识。

**数据结构是一门学科，它教会我们如何存储具有复杂关系的数据更有助于后期对数据的再利用**



#### 一、数据结构和分类

##### 1、概念

数据结构是计算机科学中一种特殊的**数据组织**方式，它允许数据在计算机中按照**指定格式**进行有效的存储，来应对不同的业务场景。如消息队列，播放列表（）、购物车列表（数组）

总结：**数据结构就是我们自定义的复杂的数据类型（比如动态数组就是一个数据结构）**

数据结构是根据业务数据需求，而定制的一个结构体类型。主要目的就是能够更方便的批量处理业务数据。

##### 2、作用

数据结构可以实现在解决不同数据场景问题时，用**最合适的格式来进行数据的处理**。

##### 3、好处

> - **提高代码效率**:合适的数据结构可以提高代码的执行效率。不同的问题可能需要不同的数据结构，选择合适的数据结构有助于优化代码的时间和空间复杂度
> - **管理大规模数据**:在处理大规模数据时，数据结构的选择对于系统的性能至关重要。合理的数据结构可以提高数据的存储效率和访问速度
> - **代码复用**:良好的数据结构可以提高代码的可重用性。通过封装数据结构，可以使代码更具模块化，便于在不同的程序中重复利用

##### 4、一些常见的数据结构

数据结构在计算机科学中是非常重要的一部分，常见的数据结构类型有以下几种：

1. 动态数组（顺序表或链表）（Array）：数组是一种线性数据结构，它包含相同类型的元素。在数组中，每个元素都有一个相关的索引，通过索引可以直接读取或修改元素，基础数据结构。对应的常见数据结构为顺序表

   

2. 栈（Stack）：栈是一种线性的数据结构，它遵循LIFO（后进先出）的原则，即最后进入的元素第一个被取出。

   - 基础数据结构：栈的“后进先出”特性使它在特定情况下非常有用，比如在实现**函数调用、表达式求值、undo操作、浏览器的前进后退等场**景时。

     

3. 队列（Queue）：队列也是一种线性的数据结构，但它遵循FIFO（先进先出）的原则，即最先进入的元素先出。

   - 基础数据结构：队列的“先进先出”特性使得它在处理需要按顺序执行的任务中非常有用，比如**CPU的任务调度，打印任务队列，消息队列、短信推送队列**等

     

4. 链表（Linked List）：链表是一种线性数据结构，由一系列相连的节点构成。每个节点包含数据部分和指向下一个节点的链接。

   - 链表用于实现**文件系统中的目录结构，社交网络中的好友关系**。在需要常常进行插入和删除操作的场景中使用链表，因为链表的插入和删除操作只需要较短的时间（O(1)）

     

5. 树（Tree）：

   > ​		树是一种非线性数据结构，典型的树结构包括二叉树、二叉搜索树、平衡树如AVL树、堆等。
   >
   > ​		属于较复杂的数据结构。在数据存储方面，比如文件系统就使用了树形结构。二叉搜索树是数据库索引的基础。计算机的文件目录、网页的DOM结构、解析表达式、路由协议等都会使用到树.

   

6. 图（Graph）：

   > ​		在数据结构中，图是一种非常重要的非线性数据结构，它被广泛用于表示和存储具有“多对多”关系的数据。图由一组顶点（也称为节点）和连接这些顶点的一系列边组成。这些顶点和边可以用于模拟现实世界中实体之间的关系和连接。
   >
   > ​		图是一组节点和连接这些节点的边的集合。节点也称为顶点，边也可称为弧。图可以是无向的（边没有方向）或是有向的（边有方向）。
   >
   > ​		图广泛应用于计算机网络、社交网络、地图软件等领域。例如，地图软件中的地点和道路可以分别作为图的节点和边，以此来计算最短路径

   

7. 哈希表（Hash Table）：

   > ​		在数据结构中，哈希表（也被称为散列表）是一种非常重要的数据结构，它提供了高效的键值对存储和检索机制。哈希表使用哈希函数将键映射到表中的位置，从而允许快速地完成插入、删除和查找操作，前提是哈希函数能够均匀分布键。
   >
   > - 哈希表是一个非常有用且有效率的数据结构，使用它可以在平均时间复杂度为O(1)的情况下搜索、插入和删除数据。Python中的字典，Java中的HashMap等都是哈希表的应用

   

8. 堆（Heap）：堆通常是一个可以被看做一棵树的数组对象。它满足堆特性，即给定一个节点 i 的话，分为最大堆和最小堆：
   - 如果是最大堆，关键字最大的记录项目是在根节点；

   - 如果是最小堆，关键字最小的记录项目是在根节点。

   - 作用：堆在优先队列，如摩斯码生成，数据压缩等都有使用。在找最大或最小元素时，使用堆的效率很高。例如，我们可能会把时间最短的任务优先处理，这时候我们就可以使用最小堆

     

##### 5、数据结构的组成

任何一种数据结构都有几个部分组成。只是不同的数据结构之间组成可能不一致，所以这里我们列出常见的组成成分，所以后续在面对不同数据结构时不能一概而论，视情况具体分析。

（1）一般组成

**数据元素**：是数据结构中的重要组成成分。具体的数据类型视情况而定，有可能只是一个int类型数据，有可能有两个或以上的数据（比如，一个int 、一个char、一个int[]等）,也有可能是另一个结构体（比如学生数据），如下所示：

> 学员学号 姓名 性别 出生日期 .....
> 1 张三 男 2000/09/09 
> 2 李四 女 2001/10/10 

**逻辑结构**：

是指数据元素之间的抽象关系（如邻接关系、从属关系等），比如学生姓名和年龄就是邻接关系，部门和员工之间就是从属关系，而这种关系是抽象的，我们需要自己选择合适的数据类型来决定数据结构中各个数据的逻辑关系。比如顺序表结构就包含了以下内部数据;

```c
创建了一个数据结构List，用于保存int型数据，可以理解为一个动态int型数组
struct List{
    User *head;//数组第一个数据的地址，
    int length;//当前数据的个数
    int capacity;//当前数组的容量
}

或
    
typedef struct List{
	int *head;  	// 申明一个指针，指向一个长度不定的数组(动态数组)
	int length; 	// 记录当前顺序表的实际元素个数
	int capacity;	// 当前顺序表的容量

} List; // 和前面的 typedef配合，直接用 List 申明结构体 
```

**存储结构**
逻辑结构在计算机中的具体实现方法
分为**顺序存储方法**、**链式存储方法**两大类、以及基于前面两大类扩展的索引存储方法、散列存储等方
法。即基于某种数据结构的不同数据之间是以什么方式来存储的。比如顺序表的不同具体数据之间，比如学生1、学生2之间的存储方式是顺序存储方式。不同的数据结构存储方式是不一样的，根据具体情况来决定（不断积累）
**数据运算**
对数据进行的操作，如插入、删除、查找、排序等，也就是数据结构的一些基础操作



##### 6、数据存储方式

数据的存储结构指的是数据的逻辑结构在计算机存储器中的映象（或表示）。存储结构是通过计算
机语言所编制的程序来实现的，因而是依赖于具体的计算机语言的，这里介绍常用的两种存储结构

- 线性存储（顺序存储）
- 非线性存储(链式存储)



（1）线性存储

概念：将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为线性存储结构（简称
线性表）
分类：线性表存储结构可继续细分为**顺序存储**结构和**链式存储**结构，即:

![](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311121100.png)

（2）线性结构特点：

使用线性表存储的数据，如同向数组中存储数据那样，要求数据类型必须一致，也就是说，线性表
存储的数据，要么全部都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据
无法使用线性表存储

（3）线性中的顺序存储

概念：将**数据依次存储在连续的整块物理空间**中，这种存储结构称为顺序存储结构（简称顺序表）

 特点：存储相邻数据的内存空间也是连续的。

应用：比如顺序表、顺序栈、顺序队列等

<img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311121636.png" alt="image-20240311121636164" style="zoom: 67%;" />

（3）链式存储结构

概念：**数据分散的存储在物理空间中**，通过` "一根线"` 保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称链表）

<img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311121736.png" style="zoom:67%;" />

（4） 相邻数据的特点：前驱和后继
数据结构中，列表中的每个个体被称为“数据元素”（简称“元素”）
某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；
某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；

如以下图，相对于数据3而言：

<img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311121852.png" alt="image-20240311121852857" style="zoom: 80%;" />

（2）非线性结构

- 非线性结构表示的是数据的存储方式并不按顺序来进行存储。一般的非线性结构指的是树结构。比如二叉树（Binary Tree）、二叉搜索树（Binary Search Tree, BST）、满二叉树（Full Binary Tree）、完全二叉树（Complete Binary Tree）、 平衡二叉树（Balanced Binary Tree ）、B树（B-Tree）、B+树（B+ Tree）等。

树型数据结构：

- 将具有“一对多”关系的集合中的数据元素按照图 （A）的形式进行存储，整个存储形状在逻辑结构

上看，类似于实际生活中倒着的树（图（B）倒过来），所以称这种存储结构为“树型”存储结构，如下图所示：

<img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311140804.png" alt="image-20240311140804072" style="zoom:67%;" />

树结构特点：

- 常用于存储逻辑关系为 "一对多" 的数据，比如分层结构
-  树结构数据之间一般有父子关系存在

##### 8、总结

（1）什么是数据结构

- 根据项目 数据业务需求而定制的一种数据组织方式(结构体），能够更贴切业务所要求的数据格式（比如用户、地图、短信队列、电影票），同时方便进行处理。一般情况下会讲多个数据整合成一个结构体进行使用。比如动态数组一般会包含数组头节点、长度、扩容方式三个基本数据构成的结构体，可以处理一般的动态数组需求。

（2）有什么用

- 数据结构可以实现在解决不同数据场景问题时，用**最合适的格式来进行数据的处理**。

（3）存储方式

![](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311121100.png)

（4）常见的数据结构

- 之前程序发展过程中，有一些程序员创建出来的数据结构很好用，就慢慢普及，成了一个程序员必须要会的数据结构技巧。能够处理一般的业务场景（不一定要求全会）
- 基础
  - 顺序表：动态数组
  - 栈：理解函数运行机制
  - 队列：必须要掌握。线程池、任务队列
  - 链表：必须掌握，后续很多数据业务场景
  - 树：能够理解
- 进阶
  - 图
  - 哈希
  - 堆

（5）一般数据结构的实现流程

- 需要构建满足业务数据需求的定制结构体（比如使用常见数据结构中的一种）
- 书写该数据结构的初始化函数
- 书写该数据结构的对应基础操作函数
  - 查询、修改、删除、添加（插入和追加）
- 在main函数里进行测试
- 将数据结构相关代码加入到需要使用数据结构的业务代码（门禁系统）中

#### 二、顺序表结构

##### 1、概念

- 顺序表是一种基本的线性表数据结构，它通过一组地址连续的存储单元来存储数据元素

- 顺序表用于存储逻辑关系为“一对一”的数据，一般用于实现长度可变的类数组，即动态数组。

- 总结：将“具有 '一对一' 逻辑关系的数据按照**顺序连续存储到一整块物理空间上**”的存储结构就是顺序存储结构，顺序表存储数据用的就是数组

  <img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311121636.png" alt="image-20240311121636164" style="zoom: 67%;" />

##### 2、定义顺序表结构

顺序表的结构一般需要以下内容：

- 一块连续的物理空间
- 初始存储容量（可扩）；
- 目前保存的数据个数；

一般使用结构体进行定义：

```c
struct List{
    int * head; // 声明了一个名为head的长度不确定的数组，也叫“动态数组”
    int length; // 记录当前顺序表的长度
    int capacity; // 记录顺序表分配的存储容量 ，扩充方式固定，为2倍
};
```

- **length**（长度）：这个成员记录了顺序表中当前存储的元素数量（**有效数据个数**）。它是对顺序表中实际元素个数的跟踪，随着元素的插入、删除等操作而动态变化。通过这个成员，我们可以方便地知道顺序表当前的有效数据量，从而进行操作或者判断是否需要进行扩容或缩容。
- **capacity**（容量）： 容量是顺序表在分配内存时预留的空间大小。它代表了顺序表当前分配的存储空间上限（**最大数据个数**）。当顺序表中的元素数量接近容量时，可能需要进行扩容操作，以便继续向顺序表中添加元素。容量的设定可以影响顺序表的性能和内存利用效率，因为过小的容量可能导致频繁的扩容操作，而过大的容量可能浪费内存空间。
- **head**（元素存储区域指针）： 这是一个指向存储顺序表元素的数组或动态分配的内存块的指针。
  它使我们能够动态管理顺序表的元素（指向数组的第一个数据）。通过指针，可以直接访问和操作存储区域，实现插入、删除、修改等操作。使用指针而不是静态数组，能够根据需要动态分配内存，以适应不同大小的顺序表，提高灵活性和效率

##### 3、顺序表实现流程

（1）初始化工作

- 给 head 动态数据申请足够大小的物理空间；
- 给 capacity 和 length 赋初值

我们定义一个函数用于完成顺序表的初始化, 并在main函数中测试：

```c
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

// 定义初始容量
#define INIT_SIZE 2

typedef struct List {
	int *head;  	// 指向数据(数组的0号位置)头的指针
	int length; 	// 数据的长度（元素个数）
	int capacity;   // 容量

} List;

// 初始化函数 （直接返回结构体List）
List init(){
	// 初始化List，其实就是给三个成员赋值
	List list;
	list.head = malloc( INIT_SIZE * sizeof(int));
	if(list.head == NULL){
		fprintf(stderr, "List内在分配失败!");
		exit(0); // 退出程序	
	}
	// 初始化有效数据个数：
	list.length = 0;
	list.capacity = INIT_SIZE;
	return list;
}

// 初始化函数 (返回结构体指针)
List* init2(){
	// 初始化List，其实就是给三个成员赋值
	// 动态分配List结构体
    List *list = malloc(sizeof(List));
    if (list == NULL) {
        fprintf(stderr, "List结构体分配失败!");
        exit(EXIT_FAILURE); // 使用EXIT_FAILURE表示错误退出
    }

	list->head = malloc( INIT_SIZE * sizeof(int));
	if(list->head == NULL){
		fprintf(stderr, "List里Data内在分配失败!");
		exit(EXIT_FAILURE); // 退出程序	
	}
	// 初始化有效数据个数：
	list->length = 0;
	list->capacity = INIT_SIZE;

	return list;
}

```

（3）顺序表的常见操作

- 插入元素
  1. 通过遍历找到数据元素要插入的位置，然后将要插入位置元素以及后续的元素整体向后移动一个位置，将新元素放到腾出来的位置上
  2. 如果容量不够，在插入元素之前进行扩容

```c
// 增
bool add( List *list, int data ){
	// 1: 先判断是否要扩容
	if(list->length == list->capacity){
		// 1-1: 要扩容
		increament(list);
	}
	// 2-1: 再添加数据到列表　
	list->head[list->length] = data;// 新值加到最后一个位置
	list->length++;
	
}
```

- 扩容函数(新长度为原来的两倍):

```c
// 扩容
void increament(List *list){
	int newSize = list->capacity*2;
	int *temp = realloc(list->head , newSize * sizeof(int));
	//对新分配的内存进行初始化 
	memset( temp + list->length, 0 , sizeof(int) * newSize / 2 );
	// 更新容量
	list->capacity = newSize;
	// 重新给head赋值：
	list->head = temp;
}
```

- 删除元素
  1. 通过遍历，找到需要删除的目标元素的位置
  2. 将后续所有元素向前移动一个位置
  3. 长度-1

<img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311143730.png" alt="image-20240311143730675" style="zoom:67%;" />

```c
// 删除数据
void delete(List *list, int index){
	// 1: 先判断索引是否有效
	if(index < 0 || index > list->length){
		fprintf(stderr, "索引无效!");
		//exit(EXIT_FAILURE);  //  退出程序
		return ;
	}
	// 删除操作：
	list->head[index] = 0;
	// 后面的数据前移
	for(int i = index; i < list->length-1; i++){
		list->head[i] = list->head[i+1];
	}
	// 最后一个位置置0：
	list->head[list->length-1] = 0;
	list->length--;
}
```

注意：如果没有 list->length--，最后一个元素仍然会存在，-1之后只是遍历不到而已

- 查找元素

```c
// 查
int get(List *list, int index ){
	//1: 判断索引是否有效
	if(index < 0 || index > list->length){
		fprintf(stderr, "索引无效!");
		exit(EXIT_FAILURE); // 退出程序	
		//return;	
	}
	return list->head[index];
}

```

- 修改元素

```c
// 改
void set(List *list , int index , int data){
	//1: 判断索引是否有效
	if(index < 0 || index > list->length){
		fprintf(stderr, "索引无效!");
		//exit(EXIT_FAILURE); // 退出程序	
		return;	
	}
	list->head[index] = data;
}
```

- 完整的代码：

``` c
/***************************************************
# File Name:    67-顺序表List.c
# Author:       SuperYu
# Mail:         yujian001002@163.com.com
# Created Time: 2024年11月19日 星期三 11时43分58秒
****************************************************/
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

// 定义初始容量
#define INIT_SIZE 2

typedef struct List {
	int *head;  	// 指向数据(数组的0号位置)头的指针
	int length; 	// 数据的长度（元素个数）
	int capacity;   // 容量

} List;

// 初始化函数
List init(){
	// 初始化List，其实就是给三个成员赋值
	List list;
	list.head = malloc( INIT_SIZE * sizeof(int));
	if(list.head == NULL){
		fprintf(stderr, "List内在分配失败!");
		exit(0); // 退出程序	
	}
	// 初始化有效数据个数：
	list.length = 0;
	list.capacity = INIT_SIZE;
	return list;
}

// 初始化函数
List* init2(){
	// 初始化List，其实就是给三个成员赋值
	// 动态分配List结构体
    List *list = malloc(sizeof(List));
    if (list == NULL) {
        fprintf(stderr, "List结构体分配失败!");
        exit(EXIT_FAILURE); // 使用EXIT_FAILURE表示错误退出
    }

	list->head = malloc( INIT_SIZE * sizeof(int));
	if(list->head == NULL){
		fprintf(stderr, "List里Data内在分配失败!");
		exit(EXIT_FAILURE); // 退出程序	
	}
	// 初始化有效数据个数：
	list->length = 0;
	list->capacity = INIT_SIZE;

	return list;
}

// 扩容的方法
void increament(List *list){
	int newSize = list->capacity * 2;
	int *temp = realloc( list-> head , newSize * sizeof(int));
	// 更新容量　
	list->capacity = newSize;
	// 重新给list的head赋值
	list->head = temp;
}

// 增
bool add( List *list, int data ){
	// １：先判断是否要扩容
	if(list->length == list->capacity){
		// １：要扩容
		increament(list);
	}
	// 2－１: 再添加数据到列表　
	list->head[list->length] = data;// 新值加到最后一个位置
	list->length++;
	
}

// 删
void del(List *list, int index){
	//1: 判断索引是否有效
	if(index < 0 || index > list->length){
		fprintf(stderr, "索引无效!");
		//exit(EXIT_FAILURE); // 退出程序	
		return;	
	} 
	// 删除操作
	list->head[index] = 0;
	// 后面的数据前移
	for(int i = index; i < list->length; i++){
		list->head[i] = list->head[i+1];
	}
	// 最后的位置也要设置成0;
	list->head[list->length - 1] = 0;
	list->length--;
}


// 改
void set(List *list , int index , int data){
	//1: 判断索引是否有效
	if(index < 0 || index > list->length){
		fprintf(stderr, "索引无效!");
		//exit(EXIT_FAILURE); // 退出程序	
		return;	
	}
	list->head[index] = data;
}
// 查
int get(List *list, int index ){
	//1: 判断索引是否有效
	if(index < 0 || index > list->length){
		fprintf(stderr, "索引无效!");
		exit(EXIT_FAILURE); // 退出程序	
		//return;	
	}
	return list->head[index];
}

// 显示数据
void toString(List *list){
	printf("当前元素个数：%d，容量是：%d,", list->length, list->capacity);
	printf("数据：[");
	for(int i = 0; i < list->length; i++){
		if(i == list->length -1){
			printf("%d ", list->head[i] );
		}else {
			printf("%d ,", list->head[i] );
		}
	}
	printf("]\n");
}

int main() {
	List *list = init2();

	add(list, 100);
	add(list, 200);
	add(list, 300);
	add(list, 400);
	toString(list);

	del(list,2);
	toString(list);

	add(list, 500);
	add(list, 600);

	set(list, 2 , 800);

	toString(list);
	
	puts("-------------");

	for(int i = 0; i<list->length; i++){
		printf("list:%d \n", list->head[i]);
	}

	return 0;
}
```

- 我们可以把列表中的数据，改成一个结构体：

  > 以下是做了部份修改的代码：

``` c
/***************************************************
# File Name:    67-顺序表List.c
# Author:       SuperYu
# Mail:         yujian001002@163.com.com
# Created Time: 2024年11月19日 星期三 11时43分58秒
****************************************************/
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

// 定义初始容量
#define INIT_SIZE 2

typedef struct User{
	char name[32];
	int age;

}User;
typedef struct List {
	User *head;  	// 指向数据(数组的0号位置)头的指针
	int length; 	// 数据的长度（元素个数）
	int capacity;   // 容量

} List;

// 初始化函数
List* init(){
	// 初始化List，其实就是给三个成员赋值
	// 动态分配List结构体
    List *list = malloc(sizeof(List));
    if (list == NULL) {
        fprintf(stderr, "List结构体分配失败!");
        exit(EXIT_FAILURE); // 使用EXIT_FAILURE表示错误退出
    }

	list->head = malloc( INIT_SIZE * sizeof(User));
	if(list->head == NULL){
		fprintf(stderr, "List里Data内在分配失败!");
		exit(EXIT_FAILURE); // 退出程序	
	}
	// 初始化有效数据个数：
	list->length = 0;
	list->capacity = INIT_SIZE;

	return list;
}

// 扩容的方法
void increament(List *list){
	int newSize = list->capacity * 2;
	User *temp = realloc( list-> head , newSize * sizeof(User));
	// 更新容量　
	list->capacity = newSize;
	// 重新给list的head赋值
	list->head = temp;
}

// 增
bool add( List *list, User data ){
	// １：先判断是否要扩容
	if(list->length == list->capacity){
		// １：要扩容
		increament(list);
	}
	// 2－１: 再添加数据到列表　
	list->head[list->length] = data;// 新值加到最后一个位置
	list->length++;
	
}       

// 显示数据
void toString(List *list){
	printf("当前元素个数：%d，容量是：%d \n", list->length, list->capacity);
	printf("数据：[ \n");
	for(int i = 0; i < list->length; i++){
		printf("  姓名：%s，年龄：%d \n", list->head[i].name, list->head[i].age );
	}
	printf("]\n");
}

int main() {
	List *list = init();

	User u01 = {"jack", 23};
	User u02 = {"rose", 20};

	add(list, u01);
	add(list, u02);

	toString(list);

	return 0;
}
```



##### 4、应用场景和练习

> 目前我们写的顺序表 List 里面放的是 int 类型的数据，如果要放 User , char 等类型。那么
>
> List 里面的 head 成员的类型，要做相应的变化，其它的函数有涉及到的返回值，都要做变化。
>
> 但基本逻辑是不变的。

（1）顺序表结构应用场景

- 数组
- 字符串（字符数组）

（2）练习

> 假设你正在为一个社交软件设计好友列表功能，用户的好友列表是一个顺序表，每个表元素就是一个好友的用户名。请你实现以下功能：
>
> 1. 用户可以添加新的好友到好友列表中。
> 2. 用户可以从好友列表中删除某个好友。
> 3. 用户可以将好友列表中某个好友的用户名进行修改。
> 4. 用户可以在好友列表中查找是否已添加某个好友。
>
> 请实现这个好友列表管理系统，并提供添加、移除、修改和查找功能

![image-20241120153444249](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/yujian/20241120153444.png)



#### 三、队列

> 刚刚学习过的栈有先进后出的特性，完成进制转换，浏览器前进后退等非常的适用。现
> 在有这样的需求：将使用短信验证码进行登录的用户统一进行收集，然后根据用户操作的先后顺序，依次响应用户的操作，使用栈来存储用户的操作还合适不？
>
> - 当然不行，总不能最先进行操作的倒还最后来执行吧。这个时候我们需要一种“先进
>   先出(先操作先响应)”的数据结构。
> - 队列就拥有这样先进先出的特性

##### 1、队列概念

- 与栈结构不同的是，队列的两端都"开口"，要求数据只能从一端进，从另一端出
- 通常，**称进数据的一端为 "队尾"**，**出数据的一端为 "队头"**，数据元素进队列的过程称为 "**入队**"，出队列的过程称为 "**出队**"
- 队列中数据的进出要遵循 **"先进先出"** 的原则，即**最先进队列的数据元素，同样要最先出队列**

![image-20240311152338362](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311152338.png)

##### 2、队列特点

（1）基于队列结构的特点，在实际应用中，通常只会对队列执行以下两种操作:

- 向队列中添加元素，此过程被称为"入队"
- 从队列中提取出指定元素，此过程被称为"出队"



（2）队列是一种 "特殊" 的线性（或链式）存储结构，因此栈的具体实现有以下两种方式

- 顺序队列：在顺序表的基础上实现的队列结构 （数组实现）
- 链队列：在链表的基础上实现的队列结构 （键表实现）



（3）常用应用场景

- 消息队列

- 任务调度

- 事件驱动系统

- 缓存更新
  ......

  

##### 3、队列实现

（1）队列结构的定义和初始化函数：

````c
typedef struct Queue{
	int *data;  	// 申明一个指针，指向一个长度不定的数组(动态数组)
	int length; 	// 记录当前队列的实际元素个数
	int capacity;	// 当前队列的容量
	int front;		// 记录第一个元素的位置
	int rear;		// 记录最后一个元素的位置

} Queue;

// 初始化队列
Queue init(int capacity){
	Queue q;
	q.data = malloc(capacity * sizeof(int));
	q.front = -1;  
    q.rear = -1;  
    q.length = 0;  
    q.capacity = capacity;

	return q;
}


````

- front

  - 表示队列的头部，即队列中第一个元素的位置

  - 当队列为空时， front 可以被设置为一个特殊的值，比如 -1

  - 在出队操作时，元素从队列头部被移除，front需要向后移动，指向下一个数据，并变为队头

    

- rear

  - 表示队列的尾部，即队列中最后一个元素的位置。

  - 当队列为空时， rear 通常也被设置为一个特殊的值，比如 -1。

  - 在入队操作时，新元素被添加到队列尾部， rear 会向后移动，指向新的队尾

    

- 这样设计的原因：使得队列的操作更加清晰、简单，并提高了对队列状态的判断效率

  - **方便插入和删除操作**： 通过维护 front 和 rear ，我们可以方便地执行队列的插入（入队）
    和删除（出队）操作。新元素总是从队尾插入，而元素总是从队头删除，这符合队列的先进先
    出（FIFO）特性。
    **快速判断队列状态**： 通过 front 和 rear 的位置，我们可以迅速判断队列的状态，例如，
    队列是否为空或已满。当 front 和 rear 相等时，队列为空；当 rear 接近数组末尾时，可
    能需要注意队列是否已满。
  - **数组实现的优势**： 在数组实现队列时，使用 front 和 rear 可以轻松地定位队列的头尾，
    因为数组的访问是通过索引实现的。这样设计简化了队列的实现和操作

（2）入列

将元素在队尾处添加

```c
// 入列
void add(Queue *q, int value){
	// 自动执行扩容操作	
	toBig(q);

	// 元素数和容量相等，说明元素满了．
	if(q->length == q->capacity){
		toBig(q);
	}
	// 向最后一个位置添加数据
	q->data[q->rear+1] = value;
	// 元素个数加１
	q->length++;
	// 尾部指针加１	
	q->rear++;
	// 首指针处理
	if(q->front == -1){
		q->front++;
	}
}
```

（3）出队:删除队头的数据

```c
// 出列
int out(Queue *q){
	// 队列不为空，才进行出列的操作
	if(q->length > 0){
		// 出列是第一个元素向后移一位
		int temp = q->data[q->front];
		// 出列后的数据置零
		q->data[q->front] = 0;

		// 如果当前是最后一个
		if(q->length == 1){
			q->front = -1;
			q->rear = -1;
		}else {
			// 首位后移
			q->front += 1;
		}
		// 元素个数减１
		q->length -=1;
		return temp;
	}
	return 0;
}
```

（4）扩容操作：

```c
// 扩容的方法
void toBig(Queue *q){
	// 1: 容量扩大(当 length==capacity 时)
	if(q->length == q->capacity){
		int newSize = q->capacity * 2;	
		// 使用realloc() 进行扩容操作，会自动复制原数据
		int *temp = realloc(q->data, newSize * sizeof(int) );
		// 更新容量
		q->capacity = newSize;
		// 使用realloc()函数后，原data的内存已经释放掉了．所以不需要再手动释放内存．
		// 重新给head赋新值
		q->data = temp;

	}else if(q->rear+1 == q->capacity && q->length < q->capacity / 2){
		// 2: 位移(当rear+1和容量值相等时,但 length < capacity / 2 )
		for(int i = 0, j = q->front ; i< q->capacity && j <= q->rear ; i++, j++){
			q->data[i] = q->data[j];
		}
		// 移动数据之后，重置首和尾的位置
		q->front = 0;
		q->rear = q->length -1;
	}
}
```

（5）toString()函数：

``` c
void toString(Queue q){
	printf("当前元素个数:%d , 容量是:%d , 头索引:%d , 尾索引:%d \n", 
				q.length, q.capacity, q.front, q.rear );
	printf("数据[");

	if(q.length > 0){
		for(int i = q.front; i<= q.rear; i++){
			if(i == q.rear){
				printf("%d ", q.data[i]);
			}else{
				printf("%d , ", q.data[i]);
			}
		}
	}
	printf("] \n");
}
```



##### 	4、应用场景

（1）队列场景

- 在数据流中的缓冲：队列数据结构常常被用作缓冲，处理数据流中的间歇性负载。例如，在视频播放中，可以将未播放的视频数据暂存到一个队列里，这样就可以为数据的到来和读取提供一个缓冲，使得播放过程更为平稳
- 各种任务队列：比如打印机、短信队列、消息推送队列
- 网络流量管理：在数据通信中，特别是在网络流量管理中，队列数据结构被用来处理请求和响应。数据包根据到达的顺序进行排队，然后按照先到先服务的原则进行处理
- 操作系统：在多任务环境中，操作系统使用队列来管理和执行任务的调度。当一个任务被创建时，它被添加到队列的末尾等待执行。处理器从队列的前端取出任务进行处理

（2）练习

​		把队列改成User结构体版



#### 四、栈

> 仔细回忆一下我们常常面临的一个场景，我利用vim写了一段代码，感觉不如意，于是我分几次
> 删除了一些代码，现在我后悔了，想还原之前所写的代码，我们的操作非常简单，按u键就可以了，但是如果使用程序的思维来考虑这个问题，我们如何去保存之前所进行的操作呢？
> 我们得先考虑一下这个需求的特点：
> 
> - 根据操作步骤的先后，最近的操作最先被还原，按时间从近到久依次进行还原。我们
>之前所学习的顺序表能完美的实现这个需求不？
> - 我们需要有一个 能够 “先进后出(后进先出)” 的数据结构，这种数据结构就是栈

##### 1、栈概念

同顺序表和链表一样，栈也是用来存储逻辑关系为 "一对一" 数据的线性存储结构（一块连续空间来保存数据，即一个数组）

- 栈是一种**只能从数组的一端存取（存储和读取）数据**且遵循 "**先进后出**" 原则的线性存储结构
- 仔细观察顺序表（底层实现是数组）和栈结构就会发现，它们存储数据的方式高度相似，只不过栈对数据的存取过程有特殊的限制

下图中的**栈顶就是存取数据的位置，存储和读取数据都是从这一端进行操作**。而栈底可以快速拿到最后一个数据，但不能取出（即删除），其中栈顶指的是最近加入的数据，一般程序中栈顶变量保存的是对应的下标

```c

```



<img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311145324.png" alt="image-20240311145324605" style="zoom:80%;" />

##### 2、栈的特性

基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作:

- 栈加入数据的操作称为`入栈`
- 栈删除数据的操作称为`出栈`

栈是一种 "特殊" 的线性存储结构，因此栈的具体实现有以下两种方式：

- 顺序栈：采用顺序存储结构可以模拟栈存储数据的特点，从而实现栈存储结构
- 链栈：采用链式存储结构实现栈结构

##### 3、栈应用场景

- 函数调用和递归
- 浏览器的前进和后退
- 网页浏览器的页面访问历史
- 进制转换

##### 4、栈的实现

> 在数据结构中，栈（Stack）是一种后进先出（LIFO, Last In First Out）的线性数据结构，它允许在一端（通常称为栈顶）进行插入和删除操作。
>
> 栈的基本操作包括：
>
> 压栈（push）
>
> 弹栈（pop）
>
> 查看栈顶元素（peek）
>
> 以及检查栈是否为空（isEmpty）等。

（1）定义栈结构体和初始化操作

```c
#define INIT_SIZE 6

typedef struct Stack {
	int *data;
	int capacity;
	int length;
	int top;          // 顶部位置 
	int bottom;       // 底部位置 
}Stack;

Stack* init(){
	Stack *stack = malloc(sizeof(Stack));
	stack->data = malloc(INIT_SIZE * sizeof(int));
	stack->top = -1;
	stack->bottom = -1;
	stack->length = 0;
	stack->capacity = INIT_SIZE;
	return stack;
}
```

（2）入栈：加入数据到栈中

```c
// 压栈
void push( Stack *stack, int value){ 
	// 应该判断一下，栈是否满了
	if( stack->length < stack->capacity){
		// 1：写入数据
		// 2：顶部索引要加1
		stack->data[++stack->top] = value;
		stack->length++;
		// 3：底部，只有在第一次的时候要变。
		if(stack->bottom == -1){
			stack->bottom = 0;
		}
	}else {
		puts("栈已经满了！");
	}
}
```

（3）出栈：将栈顶对应数据进行删除

```c
// 移除顶部数据
int pop(Stack *stack){
	if(!isEmpty(stack)){
		int temp = stack->data[ stack->top--];
		stack->length--;
		// 如果没有数据了：
		if(stack->top == -1){
			stack->bottom = -1;
		}
		return temp;
	}
	puts("空栈！没有数据！");
	return 0;
}
```

（4）查找栈顶元素

```c
// 查看顶部元素,但不移除
int peek(Stack *s){
	// 栈不为空，才进行出列的操作
	if(s->length > 0){
		return s->data[s->top];
	}
	printf("栈里没有数据了!\n");
	return 0;
}
```

（6）toString()

``` c
void toString(Stack *p){
	printf("当前元素个数：%d, 容量是：%d, 顶部位置：%d, 底部位置：%d \n", 
			p->length, p->capacity, p->top, p->bottom );
	printf("数据：[");
	
	if(p->length > 0){
		for(int i = p->top; i >= p->bottom; i--){
			if(i == p->bottom){
				printf("%d", p->data[i]);
			}else{
				printf("%d , ", p->data[i]);
			}
		}
	}
	printf("]\n");
}
```

(7): 释放内存：

``` c
// 释放内存
void freeStack(Stack *stack){
	free(stack->data);
	free(stack);
	puts("---- 内存回收完成 ----");
}
```

(8): 判空：

``` c
// 判断是否为空
bool isEmpty(Stack *stack){
	if(stack->length == 0){
		return true;	
	}
	return false;
}
```

（9）测试

```c
int main(int argc, char *argv[]) {

	Stack *stack = init();

	push(stack, 11);
	push(stack, 22);
	push(stack, 33);
	push(stack, 44);


	toString(stack);
	
	int a = pop(stack);
	int b = pop(stack);
	printf("移除的数据是：%d , %d \n", a, b);
	
	toString(stack);
	
	freeStack(stack);

    return 0;
}
```

##### 5、总结

- 在入栈操作时，务必检查栈是否已满，以防止数组越界
- 在出栈和访问栈顶元素时，要注意栈是否为空，以免引发未定义行为
- 需要根据实际需求设置合适的栈大小，过小可能导致溢出，过大则浪费内存

##### 6、完整代码：

``` c
/***************************************************
# File Name:    82-栈.c
# Author:       SuperYu
# Mail:         yujian001002@163.com
# Created Time: 2025年01月09日 星期四 15时13分39秒
****************************************************/

#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>

#define INIT_SIZE 6

typedef struct Stack {
	int *data;
	int capacity;
	int length;
	int top;          // 顶部位置 
	int bottom;       // 底部位置 
}Stack;

Stack* init();
// 压栈
void push( Stack *stack, int value);
// 移除顶部数据
int pop(Stack *stack);
// 查看顶部数据
int peek(Stack *stack);
// 判断是否为空
bool isEmpty(Stack *stack);
// 显示数据
void toString(Stack *p);
// 释放内存
void freeStack(Stack *stack);

// ------------------------------------------------------
int main(int argc, char *argv[]) {

	Stack *stack = init();

	push(stack, 11);
	push(stack, 22);
	push(stack, 33);
	push(stack, 44);


	toString(stack);
	
	int a = pop(stack);
	int b = pop(stack);
	printf("移除的数据是：%d , %d \n", a, b);
	
	toString(stack);
	
	freeStack(stack);

    return 0;
}
// =====================================================
Stack* init(){
	Stack *stack = malloc(sizeof(Stack));
	stack->data = malloc(INIT_SIZE * sizeof(int));
	stack->top = -1;
	stack->bottom = -1;
	stack->length = 0;
	stack->capacity = INIT_SIZE;
	return stack;
}

// 压栈
void push( Stack *stack, int value){ 
	// 应该判断一下，栈是否满了
	if( stack->length < stack->capacity){
		// 1：写入数据
		// 2：顶部索引要加1
		stack->data[++stack->top] = value;
		stack->length++;
		// 3：底部，只有在第一次的时候要变。
		if(stack->bottom == -1){
			stack->bottom = 0;
		}
	}else {
		puts("栈已经满了！");
	}
}
// 移除顶部数据
int pop(Stack *stack){
	if(!isEmpty(stack)){
		int temp = stack->data[ stack->top--];
		stack->length--;
		// 如果没有数据了：
		if(stack->top == -1){
			stack->bottom = -1;
		}
		return temp;
	}
	puts("空栈！没有数据！");
	return 0;
}
// 查看顶部数据
int peek(Stack *stack){
	if(stack->length > 0){
		return stack->data[stack->top];
	}
	return 0;
}
// 判断是否为空
bool isEmpty(Stack *stack){
	if(stack->length == 0){
		return true;	
	}
	return false;
}

// 释放内存
void freeStack(Stack *stack){
	free(stack->data);
	free(stack);
	puts("---- 内存回收完成 ----");
}


void toString(Stack *p){
	printf("当前元素个数：%d, 容量是：%d, 顶部位置：%d, 底部位置：%d \n", 
			p->length, p->capacity, p->top, p->bottom );
	printf("数据：[");
	
	if(p->length > 0){
		for(int i = p->top; i >= p->bottom; i--){
			if(i == p->bottom){
				printf("%d", p->data[i]);
			}else{
				printf("%d , ", p->data[i]);
			}
		}
	}
	printf("]\n");
}
```



#### 五、链表

> 之前已经学习过数组等数据结构，这些结构使用还是比较方便的。但是我们也应该注意到这些数据结构在存储数据时的一些不足，以数组为例，数组在创建时需要指定大小，这意着我们必须提前知道数据集的大小。在实际应用中数据的大小可能会变化，这就使得数组的使用变得不够灵活
>
> - 数组在内存中是连续存储的，因此在插入或删除元素时，可能需要进行大量的数据移动，导致效率降低
> - 如果数组已满，要添加更多的元素可能需要重新分配内存并复制数据，这是一项耗时的操作
>
> 而像数组这种顺序结构适合查询以及内存固定等操作，而如果需要考虑内存的灵活使用那么可以使用链表来处理



#### 1、链表理论

（1）基础概念

链表：别名**链式存储结构或单链表**，用于存储逻辑关系为 "一对一" 的数据。与顺序表不同，链表
**不限制数据的物理存储状态**，换句话说，使用链表存储的数据元素，其物理存储位置是随机的

它克服了数组的一些限制。链表的基本思想是将数据元素存储在节点中，而每个节点包含一个指向
下一个节点的指针。这种组织方式使得链表不需要预先分配固定大小的空间，可以根据需要动态地
分配和释放内存

线性：

<img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240626141506.png" alt="image-20240626141506005" style="zoom:33%;" /><img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240626141541.png" alt="image-20240626141541762" style="zoom: 33%;" />![image-20240626141617390](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240626141617.png)<img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240626141653.png" alt="image-20240626141653564" style="zoom: 30%;" />

链式：

![image-20240626141804911](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240626141805.png)

（2）链表特点

> 链表相比于数组、栈和队列等数据结构有一些独特的优势，主要体现在动态内存分配、插入和删
> 除操作的高效性上

- 动态内存分配：
  优势： 链表可以根据需要动态分配内存，而不需要预先定义固定的大小,这对于应对不断变化
  的数据量非常有优势。

- 高效的插入和删除操作：
  优势： 在链表中，插入和删除元素的操作是高效的，不需要移动大量元素。
- 适应动态大小：
  优势： 链表可以轻松地适应动态的数据集合，无需提前知道数据的大小。通过使用链表，可
  以方便地添加或移除关注，而无需事先分配固定大小的数组。
- 灵活性：
  优势： 链表可以轻松地支持不同类型的节点，提供更大的灵活性,形成一个灵活的数据结构。
- 避免碎片化：
  优势：在链表中，内存可以非连续存储，避免了数组可能面临的内存碎片问题

- **缺点**：如随机访问元素效率低，后面开发过程中根据具体的场景进行选择

（3）常见链表

- **单链表**
  单链表是一种基本的链表形式，它由节点构成，每个节点包含数据和一个指向下一个节点的指
  针。链表的最后一个节点指向空值（NULL），表示链表的结束
- **双链表**
  双链表是在单链表的基础上扩展而来，每个节点除了包含数据和指向下一个节点的指针外，还
  包含指向前一个节点的指针
- **循环链表**
  循环链表是一种特殊的链表形式，其尾节点指向头节点，形成一个环状结构
- **静态链表**
  所有结点都是在程序中定义的，不是临时开辟的，也不能用完后释放，这种链表称为“静态链
  表”

#### 2、单链表：链式动态数组

##### 1、概念

单链表是一种常见的数据结构，它由多个节点构成

- 每个节点包含数据和指向下一个节点的指针

- 链表的最后一个节点通常指向NULL，表示链表的结束
- 链表的头指针指向第一个节点

![image-20240311160912511](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311160912.png)

##### 2、链表节点

- 链表由多个节点构成，每个节点包含以下内容：

  - 数据元素本身，其所在的区域称为数据域
  - 指向直接后继元素的指针(指向的也是一个节点)，所在的区域称为指针域

  ![image-20240311161027164](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311161027.png)

  上图所示的结构在链表中称为节点。也就是说，链表实际存储的是一个一个的节点，真正的数据包含在这些节点中

  ![image-20240311161329339](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311161329.png)

##### 3、单链表实现

（1）单链表结构定义

单链表本质上需要一个结构体来表示一个节点()：

- 数据域用来存储数据；
- 指针域用于建立与下一个结点的联系，当此节点为尾节点时，指针域的值为NULL

```c

// 定义节点
typedef struct Node {
	int data;
	struct Node *next;
}Node;

// 定义链表：
typedef struct SingleLinked {
	Node *head;
	Node *rear;
	int length;  // 代表元素个数

} SingleLinked;

// 根据数据创建一个节点：
Node* createNode(int value);
// 初始化链表
SingleLinked* initSingleLinked(int value);
// 显示链表数据
void toString(SingleLinked *p);
// 释放内存
void freeSingleLinked(SingleLinked *p);
// 添加元素
void appendNode(SingleLinked *p , int value );
// 指定位置添加数据
void insertMiddle(SingleLinked *p, int index, int value);
// 指定位置删除数据
void deleteNodeByIndex(SingleLinked *p, int index );
// 指定位置更新数据
void updateByIndex(SingleLinked *p, int index, int value);
// 查找数据
int getByIndex(SingleLinked *p, int index);
// 反转链表
void reverse(SingleLinked *p);
```



（2）单链表的初始化 - （即创建一个新的节点）

初始化的主要工作：

- 声明一个头指针
- 创建一个节点，并让头指针指向这个节点
- 创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系

```c
Node* createNode(int value){
	Node *node = malloc(sizeof(Node));
	if(node == NULL){
		puts("内存分配失败！");
		exit(EXIT_FAILURE);
	}
	
	node->data = value;
	node->next = NULL;
	return node;
}

SingleLinked* initSingleLinked(int value){
	SingleLinked *p = malloc(sizeof(SingleLinked));
	Node *node = createNode(value);
	// 初始化的时候 ，只有一个数据，头和尾是同一个节点
	p->head = node;
	p->rear = node;
	p->length++;
	return p;
}
```

（3）单链表追加节点

```c
// 尾部添加元素
void appendNode(SingleLinked *p , int value ){
	Node *node = createNode(value);
	// 原来的尾部，要指向新的节点
	p->rear->next = node;
	// 新节点，变成了链表的尾部
	p->rear = node;  
	p->length++;
}
```

（4）删除指定位置元素

``` c
// 删除指定位置元素
void deleteNodeByIndex(SingleLinked *p, int index ){
	if(index == 0){
		Node *head = p->head; // 先得到头
		p->head = head->next; // 把原来的头的下一个，指定为新的头
		head->next = NULL;    // 把原来的头的next置空，断开和链表的联系
		free(head);  // 释放内存
		p->length--;
	}else {
		// 删除中间或尾部
		Node *temp = p->head;
		int i = 0;
		while(temp != NULL && temp->next != NULL){
			// 当 i == index 时，i就是我们要找的位置
			if(i+1 == index){
				// 找到索引位置的前一个节点，直接接向删除节点的下一个节点;
				// current是当前要删除的节点
				Node *current = temp->next;
				temp->next = current->next;
				current->next = NULL;
				p->length--;     
				free(current);  // 释放内存
				return;
			}
			temp = temp->next; // 不能放前面
			i++;
		}
		puts("--- 位置没有找到，无法删除 ---");
	}
}
```

（6）修改数据

``` c
// 修改数据
void updateByIndex(SingleLinked *p, int index, int value){
	Node *temp = p->head;
	int i = 0;
	while(temp != NULL){
		// 当 i == index 时，i就是我们要找的位置
		if(i == index){
			temp->data = value;
			break;
		}
		temp = temp->next; // 不能放前面
		i++;
	}
}
```

（5）遍历链表信息

> 利用nex指针，从头节点开始进行遍历，遍历后通过next找到下一个节点，
>
> 从而实现遍历的效果，直到next为 NULL 结束

``` c
// 遍历链表信息
void toString(Node *head){
	printf("节点数据[");
	Node *current = head;
	while(current->next!=NULL){
		printf("%d , ", current->data);
		current =current->next;
	}
	// 循环结束后，最后一个节点的数据也要打印出来
	printf("%d", current->data);

	printf("] \n");
}
```



<font color='red'>--------------------------  链表的进阶操作  ---------------------------</font>

（7）在指定位置插入节点

基本思路：

- 通过遍历，找到需要插入节点的位置
- 将前一个节点的next等于需要插入的新节点
- 新节点指向原来的nex

``` c
// 指定位置添加数据
void insertMiddle(SingleLinked *p, int index, int value){
	Node *node = createNode(value);
	// 如果index是0，代表头部插入：
	if(index == 0){
		node->next = p->head;
		p->head = node;
		p->length++;
		return;
	}
	// 中间位置插入数据：
	Node *temp = p->head;
	int i = 0;
	while(temp != NULL && temp->next != NULL){
		// 当 i == index 时，i就是我们要找的位置，我们在temp后面插入新节点　
		// i+1 代表插入到前面， i 不加1，代表 插入到后面
		if(i+1 == index){
			node->next = temp->next;
			temp->next = node;
			p->length++;
			return;
		}
		temp = temp->next; // 不能放前面
		i++;
	}
	// 如果找不到位置 ，但是位置是大于0的
	// 直接尾部加入：
	if(index > 0){
		p->rear->next = node;
		p->rear = node;  
		p->length++;
	}
}
```



（8）删除指定位置的节点

> 注意：因为可能删除头节点，所以参数使用的是二级指针

基本思路：

- 通过遍历，找到需要删除的目标节点和前一个节点
- 将前一个节点的next等于需要删除的位置节点的next
- 手动释放掉结点，回收被结点占用的存储空间

![image-20240311162255372](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311162255.png)

```c
// 删除指定位置元素
void deleteNodeByIndex(SingleLinked *p, int index ){
	if(index == 0){
		Node *head = p->head; // 先得到头
		p->head = head->next; // 把原来的头的下一个，指定为新的头
		head->next = NULL;    // 把原来的头的next置空，断开和链表的联系
		free(head);  // 释放内存
		p->length--;
	}else {
		// 删除中间或尾部
		Node *temp = p->head;
		int i = 0;
		while(temp != NULL && temp->next != NULL){
			// 当 i == index 时，i就是我们要找的位置
			if(i+1 == index){
				// 找到索引位置的前一个节点，直接接向删除节点的下一个节点;
				// current是当前要删除的节点
				Node *current = temp->next;
				temp->next = current->next;
				current->next = NULL;
				p->length--;     
				free(current);  // 释放内存
				return;
			}
			temp = temp->next; // 不能放前面
			i++;
		}
		puts("--- 位置没有找到，无法删除 ---");
	}
}
```

**注意**：删除的节点的空间需要手动释放

（9）反转链表

``` c
// 反转链表
void reverse(SingleLinked *p){
	// 前节点
	Node *prev = NULL;
	// 当前节点
	Node *current = p->head;
	// 后节点
	Node *next = NULL;
	
	while(current != NULL){
		next = current->next;   // 保存下一个节点
		current->next = prev;   // 反转当前节点指针
		prev = current;         
		current = next;
	}
	p->head = prev;
}
```

- 测试反转：

``` c
	Node *head = createNode(11);
	// 添加节点　
	appendNode(head,22);
	appendNode(head,33);
	appendNode(head,44);
	appendNode(head,55);
	// 调用函数之后，要更新头节点信息.
	head = reverse(head);
	toString(head);
```



（10）根据index修改节点数据

基本思路：

- 遍历，找到目标元素
- 直接修改该元素的值

> 修改功能让学生来写。。。。。





- 单向链表的完整代码：

  ``` c
  /***************************************************
  # File Name:    84-单向链表.c
  # Author:       SuperYu
  # Mail:         yujian001002@163.com
  # Created Time: 2025年01月10日 星期五 09时37分55秒
  ****************************************************/
  
  #include <stdio.h>
  #include <stdbool.h>
  #include <string.h>
  #include <stdlib.h>
  
  // 定义节点
  typedef struct Node {
  	int data;
  	struct Node *next;
  }Node;
  
  // 定义链表：
  typedef struct SingleLinked {
  	Node *head;
  	Node *rear;
  	int length;  // 代表元素个数
  
  } SingleLinked;
  
  // 根据数据创建一个节点：
  Node* createNode(int value);
  // 初始化链表
  SingleLinked* initSingleLinked(int value);
  // 显示链表数据
  void toString(SingleLinked *p);
  // 释放内存
  void freeSingleLinked(SingleLinked *p);
  // 添加元素
  void appendNode(SingleLinked *p , int value );
  // 指定位置添加数据
  void insertMiddle(SingleLinked *p, int index, int value);
  // 指定位置删除数据
  void deleteNodeByIndex(SingleLinked *p, int index );
  // 指定位置更新数据
  void updateByIndex(SingleLinked *p, int index, int value);
  // 查找数据
  int getByIndex(SingleLinked *p, int index);
  
  // 反转链表
  void reverse(SingleLinked *p);
  
  // -----------------------------------------------
  int main(int argc, char *argv[]) {
  	
  	int value = 11;
  	SingleLinked *p = initSingleLinked(value);
  	appendNode(p, 22);	
  	appendNode(p, 33);	
  	appendNode(p, 44);	
  	appendNode(p, 55);	
  	toString(p);
  	puts("----------------------");
  	
  	int a = getByIndex(p, 0);
  	int b = getByIndex(p, 2);
  	int c = getByIndex(p, 4);
  	int d = getByIndex(p, 10);
  	printf("%d , %d , %d , %d \n",a,b,c,d);
  //	insertMiddle(p, 0, 99);
  //	insertMiddle(p, 2, 88);
  //	insertMiddle(p, 7, 100);
  //	insertMiddle(p, 15, 200);
  //	toString(p);
  //	puts("----------------------");
  	
  	//deleteNodeByIndex(p, 5);
  	
  	//reverse(p);
  	
  	
  	toString(p);
  	
  	freeSingleLinked(p);
      return 0;
  }
  // ===============================================
  
  Node* createNode(int value){
  	Node *node = malloc(sizeof(Node));
  	if(node == NULL){
  		puts("内存分配失败！");
  		exit(EXIT_FAILURE);
  	}
  	
  	node->data = value;
  	node->next = NULL;
  	return node;
  }
  
  SingleLinked* initSingleLinked(int value){
  	SingleLinked *p = malloc(sizeof(SingleLinked));
  	Node *node = createNode(value);
  	// 初始化的时候 ，只有一个数据，头和尾是同一个节点
  	p->head = node;
  	p->rear = node;
  	p->length++;
  	return p;
  }
  
  // 尾部添加元素
  void appendNode(SingleLinked *p , int value ){
  	Node *node = createNode(value);
  	// 原来的尾部，要指向新的节点
  	p->rear->next = node;
  	// 新节点，变成了链表的尾部
  	p->rear = node;  
  	p->length++;
  }
  
  // 指定位置添加数据
  void insertMiddle(SingleLinked *p, int index, int value){
  	Node *node = createNode(value);
  	// 如果index是0，代表头部插入：
  	if(index == 0){
  		node->next = p->head;
  		p->head = node;
  		p->length++;
  		return;
  	}
  	// 中间位置插入数据：
  	Node *temp = p->head;
  	int i = 0;
  	while(temp != NULL && temp->next != NULL){
  		// 当 i == index 时，i就是我们要找的位置，我们在temp后面插入新节点　
  		// i+1 代表插入到前面， i 不加1，代表 插入到后面
  		if(i+1 == index){
  			node->next = temp->next;
  			temp->next = node;
  			p->length++;
  			return;
  		}
  		temp = temp->next; // 不能放前面
  		i++;
  	}
  	// 如果找不到位置 ，但是位置是大于0的
  	// 直接尾部加入：
  	if(index > 0){
  		p->rear->next = node;
  		p->rear = node;  
  		p->length++;
  	}
  }
  // 删除指定位置元素
  void deleteNodeByIndex(SingleLinked *p, int index ){
  	if(index == 0){
  		Node *head = p->head; // 先得到头
  		p->head = head->next; // 把原来的头的下一个，指定为新的头
  		head->next = NULL;    // 把原来的头的next置空，断开和链表的联系
  		free(head);  // 释放内存
  		p->length--;
  	}else {
  		// 删除中间或尾部
  		Node *temp = p->head;
  		int i = 0;
  		while(temp != NULL && temp->next != NULL){
  			// 当 i == index 时，i就是我们要找的位置
  			if(i+1 == index){
  				// 找到索引位置的前一个节点，直接接向删除节点的下一个节点;
  				// current是当前要删除的节点
  				Node *current = temp->next;
  				temp->next = current->next;
  				current->next = NULL;
  				p->length--;     
  				free(current);  // 释放内存
  				return;
  			}
  			temp = temp->next; // 不能放前面
  			i++;
  		}
  		puts("--- 位置没有找到，无法删除 ---");
  	}
  }
  // 修改数据
  void updateByIndex(SingleLinked *p, int index, int value){
  	Node *temp = p->head;
  	int i = 0;
  	while(temp != NULL){
  		// 当 i == index 时，i就是我们要找的位置
  		if(i == index){
  			temp->data = value;
  			break;
  		}
  		temp = temp->next; // 不能放前面
  		i++;
  	}
  }
  // 查找数据
  int getByIndex(SingleLinked *p, int index){
  	Node *temp = p->head;
  	int i = 0;
  	while(temp != NULL){
  		// 当 i == index 时，i就是我们要找的位置
  		if(i == index){
  			return temp->data;
  		}
  		temp = temp->next; // 不能放前面
  		i++;
  	}
  	return 0;
  }
  
  // 反转链表
  void reverse(SingleLinked *p){
  	// 前节点
  	Node *prev = NULL;
  	// 当前节点
  	Node *current = p->head;
  	// 后节点
  	Node *next = NULL;
  	
  	while(current != NULL){
  		next = current->next;   // 保存下一个节点
  		current->next = prev;   // 反转当前节点指针
  		prev = current;         
  		current = next;
  	}
  	p->head = prev;
  }
  
  
  void toString(SingleLinked *p){
  	printf("元素个数：%d  节点的数据：[ ",p->length );
  	
  	Node *current = p->head;
  	
  	while(current != NULL){
  		printf("%d ", current->data );
  		current = current->next;
  	}
  	
  	printf("]\n");
  }
  
  
  void freeSingleLinked(SingleLinked *p){
  
  	Node *current = p->head;
  	Node *next;
  	// 循环释放内存
  	while(current != NULL){
  		next = current->next;  //先得到下一个指针
  		free(current);         //释放当前的节点内存
  		current = next;		   //替换当前节点
  	}
  	// 最后释放链表	
  	free(p);
  	puts("------- 内存释放完成 -------");
  }
  ```
```
  
  

##### 4、单链表练习

> 假设你的好友送给你一份礼物清单，每个礼物都有一个唯一的ID，而清单本身就是一个单链表。你的任务是根据你的预算，从这份清单上添加、修改、查询以及删除礼物

​```c
struct Node {
    int data;
    struct Node* next;
};
/*定义添加节点函数*/
void addGift(struct Node** head_ref, int new_data) {
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));
    struct Node *last = *head_ref;
    new_node->data  = new_data;
    new_node->next = NULL;
    if (*head_ref == NULL) {
       *head_ref = new_node;
       return;
    }
    while (last->next != NULL)
        last = last->next;
    last->next = new_node;
    return;
}

/*定义删除节点函数*/
void deleteGift(struct Node **head_ref, int key) {
   struct Node* temp = *head_ref, *prev;
   if (temp != NULL && temp->data == key) {
       *head_ref = temp->next;  
       free(temp);               
       return;
   }
   while (temp != NULL && temp->data != key) {
        prev = temp;
        temp = temp->next;
   }
   if (temp == NULL) return;
   prev->next = temp->next;
   free(temp);
}

/*定义查找节点函数*/
bool searchGift(struct Node* head, int x) {
    struct Node* current = head; 
    while (current != NULL) {
        if (current->data == x)
            return true;
        current = current->next;
    }
    return false;
}

/*定义修改节点函数*/
void updateGift(struct Node* head, int old_id, int new_id) {
    struct Node* current = head; 
    while (current != NULL) {
        if (current->data == old_id) {
            current->data = new_id;
            break;
        }
        current = current->next;
    }
}
```



单链表特点

1. 内存使用灵活，充分利用零散的内存，提高内存使用效率
2. 链表：善于插入和删除操作，不方便进行查询，并且也不支持倒序查找







#### 3、双链表

> 现在我们开发一个简易版本的音乐播放器，要实现里面有顺序播放，随机播放，上一
> 首，下一首的功能。那么问题来了，如果使用刚刚所学习的单链表来存储歌曲信息，当
> 我需要听上一首歌曲的时候，怎么实现呢？
>
> - 当使用单链表时，如果你需要获取当前节点之前的节点，就会发现相对困难，单链表
> 更适合 "从前往后" 找，而 "从后往前" 找并不是它的强项
> - 双链表可以为这种场景提供更简便的实现方案

##### 1、概念

双链表是一种链表，与单链表不同的是，每个节点有两个指针，一个指向前一个节点，一个指向后
一个节点：

- 双链表中的双，指的是各节点之间的逻辑关系是双向的

![image-20240311163435469](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311163435.png)

##### 2、双向链表中的节点

双链表中每个节点由三部分组成：
1. 指针域prev：用于指向当前节点的直接前驱节点；
2. 数据域data：用于存储数据元素。
3. 指针域：用于指向当前节点的直接后继节点

<img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311163514.png" alt="image-20240311163514510" style="zoom:80%;" />

##### 3、双向链表的好处和缺点

（1）好处

1. 在双向链表中，可以从任意方向遍历链表——即从头到尾或从尾到头。这在某些应用中很有用，比如在浏览器的前进和后退按钮中，基于双向链表可以方便地实现网页的前进和后退功能。
2. 双向链表可以更容易地在链表的任意位置插入或删除节点。在单链表中，如果我们想要删除一个节点，我们需要在常规的情况下维持对前驱节点的引用，然而在双向链表中，我们可以直接获取前驱节点。
3. 有时候，在某些类型的数据处理中，我们需要回溯，双向链表提供了这种可能。单链表则不行，它只能向前移动。
4. 双向链表可以用于实现更多复杂的数据结构，如链表哈希表、树形链表等

（2）缺点

1. 它需要更多的内存存储，因为它需要为每个节点存储两个指针。
2. 执行插入和删除操作类也更复杂，因为需要处理更多的指针

##### 4、双向链表的实现



（1）节点定义

同单链表相比，双链表仅是各节点多了一个用于指向直接前驱的指针域
双链表的节点类型实际上也可以使用结构体描述，此结构体包含数据域和两个指针域：

- 数据域用来存储数据；
- 将节点的 prev 指针指向直接前驱节点
- 将节点的 next 指针指向后继节点

```c
typedef struct Node{
	int data;  // 一个节点存一个数据，这里不用指针指向数组了
	// 这里的struct不能少
	struct Node *prev; // 代表当前节点指向的上一个节点,如果是头节点指向的是:NULL
	struct Node *next; // 代表当前节点指向的下一个节点,如果是尾节点指向的是:NULL
} Node;


```

（2）创建一个新节点

- 申请空间
- 将prev指针和next指针置为NULL

```c
// 创建新节点  
Node* createNode(int data) {  
    Node* node = (Node*)malloc(sizeof(Node));  
    if (!node) {  
        printf("内存分配失败\n");  
        exit(1);  
    }  
    node->data = data;  
	node->prev = NULL;
    node->next = NULL;  
    return node;  
}
```

（3）双链表追加节点

基本思路：

- 先创建一个待追加的节点元素
- 如果还没有任何的头指针，则当前待追加的节点做为头指针，否则找到最后一个节点进行追加

![image-20240311164204484](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311164204.png)

![双向-添加](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240627150424.gif)

注意：<font color='red'>追加节点的函数：返回的节点就是尾部节点</font>

```c
//追加节点(尾部插入)
Node* appendNode(Node *head, int value){
	//头节点不为空继续操作，保证程序的健壮性
	if(head==NULL){ 
		return NULL;
	}
	//在链表末尾添加新节点：不断查找，直到某个节点的next为null，那么就找到了
	Node *current = head;
	while(current->next!=NULL){
		current =current->next;
	}
	//退出循环，current就是最后一个节点
	//构建一个新节点
	Node *newNode= createNode(value);
	//新节点作为链表的最后一个节点
	current->next =newNode;
	// 新节点前一个节点指定
	newNode->prev = current;
	// 返回节点（尾部）
	return newNode;
}

```

**注意：**

- 链表一开始可能没有任何的元素，所以需要判断head是否为NULL
- while循环只是找到最后一个节点



（4）查找指定的节点

> 遍历链表，找到配置值的节点，并返回节点

``` c 
// 查找指定值的节点
Node* getNode(Node* head, int value) {  
    Node* temp = head;
    while (temp != NULL) {
        if (temp->data == value) {
            return temp;
        }
        temp = temp->next;
    }
    return NULL;
}
```

（5）显示单个节点信息：

``` c
// 显示单个节点信息
void showNode(Node *node){

	if(node != NULL){
		if(node->prev != NULL){
			printf("前节点的值:%d ", node->prev->data);
		}else {
			printf("前节点的值:NULL " );
		}
		printf("当前节点的值:%d ", node->data);
		
		if(node->next != NULL){
			printf("后节点的值:%d ", node->next->data);
		}else {
			printf("后节点的值:NULL " );
		}
		
	}else {
		printf("节点是空的");
	}
	printf("\n");
}
```

（6）遍历链表信息：

``` c
// 遍历链表信息
void toString(Node *head){
	printf("节点数据[");
	Node *current = head;
	while(current->next!=NULL){
		printf("%d , ", current->data);
		current =current->next;
	}
	// 循环结束后，最后一个节点的数据也要打印出来
	printf("%d", current->data);

	printf("] \n");
}
```

（7）释放链表的内存(清空链表)

``` c
// 释放链表的内存
void freeLinked(Node* head) {
    Node* temp;
    while (head != NULL) {
        temp = head;
        head = head->next;
        free(temp);
    }
}
```



----------------------------------- 第二步讲解内容： --------------------------------------------

（8）双联表头部插入节点

基本思路：

- 根据用户数据创建一个新的节点
- 将新创建的节点的next指向原head,将原head的prev指向新创建的节点
- 将head重置为新创建的节点指针，指向新的表头

![image-20240311164315848](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311164315.png)

```c
// 在头节点之前,插入新节点：
void insertBefore(Node **head, int value){
	// 创建新节点	
	Node *node = createNode(value);
	// 把新节点设置成头节点

	// 错误示范：
	//node->next = head; // 当参数是一级指针时，这样写是无效的
	
	// 正确示范（新节点的next指向原来的头）：
	node->next = *head;  // 头节点参数一定要是二级指针

	// 再把节点的头，设置成新节点
	*head = node;
}
```



（9）双链表指定位置插入节点

基本思路：

- 从表头依次遍历表中节点，查询是否有指定的位置，如果有：

  - 新节点先与其直接后继节点建立双层逻辑关系
  - 新节点的直接前驱节点与之建立双层逻辑关系

  ![image-20240311164434231](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311164434.png)

```c
// 在指定的位置插入节点(可能在头插入，所以直接用二级指针)　
void insertMiddle(Node **head , int index , int value){
	if (index < 0) {
        printf("无效的位置　\n");
        return;
    }
	// 根据值，创建一个新节点
    Node* newNode = createNode(value);
    if (index == 0) {
        // 插入到头部(新节点就变成了头节点)
        newNode->next = *head;
        if (*head != NULL) {
            (*head)->prev = newNode;
        }
        *head = newNode;

    } else {
		// 否则就是其它位置插入节点　
        Node* temp = *head;
        int currentIndex = 0;

        // 找到要插入位置的前一个节点
        while (temp != NULL && currentIndex < index - 1) {
            temp = temp->next;
            currentIndex++;
        }
 		if (temp != NULL) {
            // 如果找到了位置，插入节点
            newNode->next = temp->next;
            newNode->prev = temp;

            if (temp->next != NULL) {
				// 下一个节点的前节点就变成了新节点
                temp->next->prev = newNode;
            }
			// temp的下一个节点指向新节点了
            temp->next = newNode;

        } else {
            // 如果没有找到位置，直接插入到链表尾部
            appendNode(*head, value);
        }
    }
}
```

（10）双链表删除节点

基本思路：

- 从表头依次遍历表中节点，找到要删除的结点，然后将该节点从表中摘除即可

![image-20240311164534509](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311164534.png)

```c
// 删除指定值的节点(这里用的是二级指针：因为可能要删除头节点)
void deleteNode(Node** head, int value) {
   	Node *current = *head;  

    // 如果头节点就是要删除的节点  
    if (*head != NULL && (*head)->data == value) {  
		// 下一个节点设置成头
        *head = current->next;
		// 头的前节点设置为NULL
		(*head)->prev = NULL;
  
		// 释放头节点内存(即删除头节点)        
		free(current);  
        return;  
    }
	// 否则，就是删除其它节点  ------------------
    // 查找要删除的节点的位置　 
    while (current->next != NULL && current->data != value) {
		// 当前节点向后走一位
        current = current->next;
    }

	// 循环结束之后，如果　current->data == value　说明节点找到了．
	if(current->data == value){
		// 执行删除逻辑:上一个节点的下一个节点,直接指向下一个节点
		 current->prev->next = current->next;
		// 释放当前节点内存
		free(current);
		return;
	}
	printf("值有误,无法找到相应的节点! \n");
} 

```



（11）测试

```c
// =================================================
int main() {
	Node *head = createNode(11);
	// 前面插入节点(注意是二级指针，这里要传地址)：
	//insertBefore(&head, 99);

	// 添加节点，并返回尾部
	Node *rear = appendNode(head,22);
	// 后面追加节点
	rear = appendNode(head,33);
	// 显示单个节点信息
//	showNode(rear);
	rear = appendNode(head,44);
	rear = appendNode(head,55);
	// 根据值查找指定节点
	Node *node = getNode(head, 33);
	// 显示单个节点信息
	//showNode(node);

	// 传参数时要注意：因为是二级指针，所以这里传的是head的地址．
	//deleteNode(&head, 66);
	//toString(head);

	// 指定位置插入数据
	insertMiddle(&head, 9,99);

	//freeLinked(head);
	
	toString(head);

    return 0;
}
```





#### 4、循环链表

> 刚刚学习过单链表和双链表的使用。现在有一个新的需求，我们要开发一个音乐播放
> 器，当你在播放列表的最后一首歌曲结束时，接下来应该播放的是列表的第一首歌曲，
> 这种需要使用之前的单链表或者双链表怎么实现呢？
>
> - 将第一首歌存储起来
> 其实，这种循环的思想在链表中也有体现，就是**循环链表**。循环链表是一种特殊的链
> 表，其尾节点指向链表的头节点，形成一个环状结构。这种结构的设计使得循环链表在
> 某些场景下更具优势
> - 后续主要介绍单向循环列表

##### 1、概念

循环链表是一种链表，**其中最后一个节点指向第一个节点，形成一个环**
这种结构的一个显著特点是**在遍历时永远不会遇到NULL指针**，因为最后一个节点指向第一个节
点，形成一个循环

![image-20240311165055808](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240311165055.png)

##### 2、好处和优势

- 遍历方便
- 插入和删除操作效率高

##### 3、应用场景

##### 4、循环链表实现

（1）节点结构体定义

```c
#include <stdio.h>
#include <stdlib.h>
// 定义循环链表节点
struct Node {
    int data;
    struct Node* next;
};
```

（2）初始化循环链表

```c
// 初始化循环链表
struct Node* initCircularList(int data) {
    struct Node* head = (struct Node*)malloc(sizeof(struct Node));
    if (!head) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }
    head->data = data;
    head->next = head; // 将尾节点指向头节点形成循环
    return head;
}
```

**注意**：将尾节点指向头节点形成循环

（3）添加节点

```c
// 在循环链表尾部添加元素
void appendToCircularList(struct Node* head, int data) {
    // 申请空间
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        perror("内存错误");
        exit(EXIT_FAILURE);
    }
    newNode->data = data;
    // 将新节点的指针指向头节点
    newNode->next = head;
    
    struct Node* current = head;
    while (current->next != head) {
        current = current->next; // 移动到链表的最后一个节点
    }
    // 将尾节点的指针指向新节点
    current->next = newNode;
}
```



- 基本跟单链表是一样的

（4）删除节点

关键在于找到需要删除的节点及前一个节点，让前一个节点的next指向要删除的节点的next:

```c
// 在循环链表中删除指定元素
void deleteFromCircularList(struct Node* head, int data) {
    // 要删除的节点
    struct Node* current = head;
    // 要删除的节点的前一个节点
    struct Node* previous = NULL;
    // 根据用户传入的值 查找要删除的节点和其前一个节点
    while (current->data != data && current->next != head) {
        previous = current;
        current = current->next;
    }
    // 找到最后了都没有找到则说明没这个值
    if (current->data != data) {
        printf("数据 %d 未找到\n", data);
        return;
    }
    // 如果要删除的是头节点
    if (current == head) {
        previous = head;
        // 移到最后一个节点
        while (previous->next != head) {
            previous = previous->next;
        }
        head = head->next;
        previous->next = head;
    } else {
        previous->next = current->next;
    }
    free(current);
}
```



（5）修改节点

```c
// 修改循环链表中特定节点的值
// target_data:目标值
// new_data:新的值
void modifyNodeValue(struct Node* head, int target_data, int
                     new_data) {
    struct Node* current = head;
    // 如果链表不为空
    if (head != NULL) {
        do {
            // 找到要修改值的节点
            if (current->data == target_data) {
                // 修改节点的值
                current->data = new_data;
                break; // 找到节点后退出循环
            }
            current = current->next;
        } while (current != head);
    }
}
```

（6）查询节点

```c
void printNode(Node *head){
    if(head==NULL){
        return;
    }
    Node * current = head;
    do {
        printf("%d",current->data);
        current = current->next;
    }while(current!=NULL);
    return;
}
```



#### 六、数据结构总结

- 分类
  - 存储结构方式
    - 数组（线性）：连续的存储空间
    - 链式：非连续存储空间
  - 存储数据结构
    - 表
      - 顺序表：动态数组
        - 特点：自带下标机制
        - 方便：查询
        - 不足：插入和删除：需要移动，扩容固化（不灵活）
      - 顺序链表
        - 特点：不带下标机制，内存使用高效
        - 方便：插入、删除
        - 不足：查询、每个数据使用空间较大（一个数据一个节点）
    - 栈(先进后出)
      - 线性栈
      - 链式栈
    - 队列（先进先出）
      - 线性队列
      - 链式队列

- 对比
  - 线性：自带下标机制。连续内存
  - 链式：高效内存使用，无下标机制
  - 队列：先进先出
  - 栈：先进后出
- 应用
  - 栈：程序函数调用底层实现
  - 队列：消息队列、任务队列、通知队列、线程池（含有任务队列）
  - 链式和线性

<img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240628141433.png" alt="image-20240628141433326" style="zoom: 50%;" /><img src="https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240628141503.png" alt="image-20240628141503292" style="zoom: 50%;" />



- 栈

![image-20240628141655291](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240628141655.png)

- 队列

  ![image-20240628142153380](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240628142153.png)
