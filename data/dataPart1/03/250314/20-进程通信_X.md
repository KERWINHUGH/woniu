## 进程通信

### 课程目标

1. 了解进程间通信有哪些方式 
2. 掌握管道通信方式的分类 
3. 掌握有名管道通信方式 
4. 掌握无名管道通信方式 、
5. 消息队列的概念及通信方式

### 课程实验

1. 使用无名管道实现亲缘间进程通信
2. 使用有名管道实现非亲缘间进程之间的通信
4. 使用 FIFO 进行 IPC 的过程

### 课堂引入

> 进程间通信是操作系统的重要功能之一。操作系统提供了一系列的机制和接口，以支持进程间通信。 进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC的方式通 常有**管道**（包括无名管道和命名管道）、**消息队列**、**信号量**、**共享内存**、**Socket**（套接字）等。其中 **Socket 和支持不同主机上的两个进程 IPC**。 进程间通信是实现多进程协同工作的关键技术之一。在多进程环境中，不同的进程需要相互通信和协 作，以实现共同的任务或目标。通过进程间通信，进程可以交换数据、共享资源、协调工作流程等。在 多进程环境中，每个进程都有自己的资源，通过进程间通信，可以避免不必要的资源浪费和重复计算， 提高程序的运行效率。

### 授课进程

#### 一、进程间通信方式简介

##### 1、IPC概念

进程间通信主要是利用内核空间，来完成两个进程或者多个进程之间的资源和信息的传递。

##### 2、进程间通信方式

进程间通信的方式有多种，常见的方式包括管道、消息队列、信号量、共享内存和套接字。

1. **管道**（Pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进 程间使用。通常用于父子进程之间的通信。 
2. **FIFO**（First In First Out，先进先出）：是一种数据结构，它遵循先进先出的原则。在操作系统 中，FIFO调度算法按照进程到达的顺序进行调度，当进程完成时，它从队列中移除。这种算法的优 点是实现简单，但缺点是它可能导致一些进程长时间等待，而其他进程却得到优先处理。 
3. **消息队列**（Message Queue）：消息队列是一种用于进程间通信或同一进程的不同线程间的通信的方式。它允许进程或线程将消息添加到队列中，并允许其他进程或线程从队列中取走消息进行处理。它是全双工的，并且可以独立于发送和接收进程存在。
4. **信号量**（Semaphore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常 常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。 
5. **共享内存**（Shared Memory）：使得两个或更多的进程能够访问同一块内存区域。对于数据量大，需要频繁更新的情况，使用共享内存通常比其他IPC方式效率更高，因为省去了用户态和内核态之间数据拷贝的时间。但是，使用共享内存通常需要依赖其他IPC方式（如信号量）来同步进程对共享内存的访问。
6. **套接字**（Socket）：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机 器间的进程通信。 这些通信方式在不同的场景和需求下有不同的应用。

#### 二、管道(PIPE)

##### 1、概念

管道，是 UNIX 系统IPC标准的形式。管道是进程间通讯的一种实现。  管道分为两种:**有名管道和无名管道**

##### 2、理解

![image-20240318093858642](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240318093905.png)

##### 2、无名管道

（1）概念

无名管道是管道通信中的一种，通常用于具有亲缘关系（如父子进程）的进程间通信。

（2）特点

- 主要用于具有亲缘关系（如父子进程或兄弟进程）的进程
- 无名管道是半双工的，即**数据只能在一个方向上流动。通常父进程写入管道，子进程从管道读取，或者相反**
- 无名管道的生命周期通常随着相关进程的终止而结束

（3）为什么叫无名

无名管道只存在于内存之中，系统自动生成了其文件描述符，其他进程无法获取这个管道来操作

（4）使用语法

Linux系统中提供了一个`pipe()`来创建一个无名管道：

```c
#include <unistd.h> 
int pipe(int pipefd[2]); 
```

- 作用：创建一个单方向的无名管道（半双工通信），要关闭管道只需将这两个文件描述符关闭即可。
- 参数
  - pipefd 指定一个有两个整型元素的数组名字。
    - pipefd[0] 指向管道读端，pipefd[0]为读而打开
    - pipefd[1] 指向管道的写端，pipefd[1]为写而打开
- 返回值
  - 成功返回0
  - 失败返回-1

（5）示例代码

```c
int main()
{
    // 创建管道文件描述符数组
    int fd[2];
    // 进程ID
    pid_t pid;
    // 缓冲区
    char buf[100];

    // 创建管道
    if(pipe(fd) < 0) {
        perror("pipe error");
        exit(1);
    }

    // 创建子进程
    pid = fork();
    if(pid < 0) {
        perror("fork error");
        exit(1);
    }

    // 如果pid大于0，说明是父进程
    if(pid > 0) {
        // 关闭管道的读端
        close(fd[0]);
        // 向管道的写端写入数据
        write(fd[1], "Hello, pipe!", 13);
        // 等待子进程结束
        wait(NULL);
    }
  
    // 如果pid等于0，说明是子进程
    else if(pid == 0) {
        // 关闭管道的写端
        close(fd[1]);
        // 从管道的读端读取数据
        read(fd[0], buf, 100);
        // 打印接收到的字符串
        printf("Child process received string: %s\n", buf);
    }

    return 0;
}
```

（6）关于无名管道

> 在操作系统中，无名管道是一种基于内核的数据结构或对象，常表现为一个字节流。它不同于普通文件，整个管道实际上被操作系统内核管理，我们通常不能直接访问或查看其内容。
>
> 无名管道的存在是为了进程间通信（IPC）提供一种方案，特别是在有亲缘关系的进程（例如父子进程）之间。无名管道由两部分组成，分别是输入队列和输出队列，这样就形成了一个FIFO（First In First Out）的数据结构。数据被写入到输入队列端，然后在输出队列端被读出。
>
> 在内存中，无名管道通常被实现为一个环形缓冲区，或者说是一个循环队列。这个缓冲区有一个读指针和一个写指针，数据被写入到写指针所指向的位置，然后写指针更新；数据从读指针所指向的位置被读出，然后读指针更新。
>
> 通过调整读写指针，操作系统可以控制数据在管道中的写入和读取。注意，数据一旦被读出，就会从管道中移除，也就是说，无名管道并不会保存已经被读取的数据。
>
> **总结：无名管道本质上是一个内核分配和管理的基于FIFO结构的输入输出队列，内部维护了输入和输出指针，方便进行父子或兄弟进程之间的数据传输**

##### 3、有名管道（命名管道）

（1）概念

进程间通信的一种。因其数据传输的特点为先入先出，使用有名管道进行通信的模式又称FIFO模式或。

（2）特点

- 有名管道则可以用于任意两个进程之间的全双工通信，无论它们之间是否存在亲缘关系
- 有名管道在文件系统中有一个具体的名字。任何知道管道名字的进程都可以使用该管道进行数据通信
- 有名管道的生命周期长于创建它的进程，除非显式地被删除，否则会一直存在于文件系统中.在C语言中可以用remove进行删除

（3）为什么叫有名

"有名"是相对于"无名"而言的,是因为它在文件系统中有一个具体的名字。这个"名字"是一个路径名，任何知道这个路径名的进程都可以通过打开这个路径名的文件来访问这个管道。这个名字可以在文件系统中被看到，也可以被其他进程引用，从而使得任意两个进程都能通过这个名字（即这个路径）进行通信，而这就是"有名"管道名字的含义和用途。

相比之下，"无名"管道（Pipe）在创建时没有对应的文件名字，它仅仅是内核中的一个数据结构。因此，无名管道的使用范围被限定在创建它的进程及其子进程之间

（4）使用有名管道

Linux提供了`mkfifo`函数用于声明实现一个又名管道。语法如下

```c
#include <sys/types.h>
#include <sys/stat.h>
int mkfifo(const char *pathname, mode_t mode);
```

功能：: 创建一个有名管道

参数

- pathname: 指定要创建的文件的名字(管道类型的文件)。
-  mode: 指定管道文件的权限 例如：0666

返回值

- 成功：返回 0
- 失败：返回-1;errno被设置为相应的错误值

（5）示例代码 

定义一个c文件用于写入数据：

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <errno.h>

// 管道文件的路径
char path[] = "/tmp/my_fifo";

int main() {
    // 创建有名管道。第一个参数是路径名，第二个参数是文件权限设置。
    // 注意如果文件已经存在，mkfifo 不会做任何事情，但是会返回一个错误。
    if (mkfifo(path, 0666) == -1 && errno != EEXIST) {
        perror("mkfifo error");
        exit(1);
    }
    
    int fd = open(path, O_WRONLY);
    if (fd == -1) {
        perror("open error");
        exit(1);
    }

    //写入数据到管道
    write(fd, "Hello, FIFO!", 13);
    close(fd);

    return 0;
}
```

定义另一个c文件用于读取数据

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

char path[] = "/tmp/my_fifo";

int main() {
    
    char buf[100];
    int fd = open(path, O_RDONLY); //只读方式打开管道
    if (fd == -1) {
        perror("open error");
        exit(1);
    }

    //从管道读取数据
    read(fd, buf, 100);
    printf("Received string: %s\n", buf);
    close(fd);

    return 0;
}
```

##### 5、管道注意点（无名）

（1）.如果管道中没有数据，read读取时会阻塞等待数据的到来（后台执行，不阻塞终端命令执行）

```c
// 第一个注意点，管道没数据进行读取时会如何
        char buf[123] = {0};
        ssize_t ret = read(fd[0], buf, sizeof(buf));
        if(-1 == ret) {
         perror("read");
         return -1;
        }
        printf("读到的数据为%s\n",buf);
```

（2）管道符合先进先出的原则，数据读走后就会消失

```c
write(fd[1], "hello world", 11);
char buf[123] = {0};
ssize_t ret = read(fd[0], buf, 5);
if(-1 == ret) {
 perror("read");
 return -1;
}
printf("读到的数据为%s\n", buf);
read(fd[0], buf, 6);
printf("读到的数据为%s\n", buf); 
```

（3） 管道的大小是64K，管道写满以后再次进行写入会阻塞等待写入

```c
nt i = 0;
char ch;
for (i = 0; i < 64*1024; i++) {
 write(fd[1], &ch, 1);
}
printf("管道已经写满\n");
write(fd[1], &ch, 1); // 及确定管道的大小
// 又确定了管道写满之后再次写入会发生什么
```

（4）如果关闭了写入端口，读会发生什么情况

- 管道中有数据时将里面的数据读出来。
- 管道中无数据时管道机制会认为写端关闭，不会再有数据到来，read在做读取时阻塞没有任何用 处，read将不会阻塞等待了。便不会影响进程运行

```c
char buf[123] = {0};
char buf1[123] = {0};
write(fd[1], "hello world", 11);
close(fd[1]); // 关闭写端
read(fd[0], buf, sizeof(buf));
printf("buf = %s\n", buf);
read(fd[0], buf1, sizeof(buf)); // 阻塞等待
printf("buf = %s\n", buf1);
```

##### 6、管道总结

- 优点
  - 无名：简单、单方向
  - 有名：双向、任意两个进程
- 缺点
  - 无名：仅支持父子进程，双向交互繁琐
  - 有名：需要读写进程打开，开销大（单独的一个内存管道缓冲区）

- 应用
  - 无名：简单的父子进程通信
  - 有名：一对一的实时两个进程通信，但两个进程关闭了，那么有名管道保存数据的缓冲区也会关闭。

#### 三、消息队列

##### 1、概念

消息队列是一种在进程间传递消息的通信机制，它允许一个或多个进程向队列写入消息，同时一个或多个进程可以从队列读取消息。

##### 2、特点

1. 消息队列是面向记录的，其中的消息具有特定的格式、类型以及优先级。 
2. 消息队列独立于发送与接收进程。进程终止时，**消息队列及其内容并不会被删除**。
3. 消息队列可以实现消息的**随机查询**,消息不一定要以先进先出的次序读取,也可以按消息的类型读 取。
   1. 进程写入不同类型的数据，读进程就可以读取指定类型的数据，不一定非要先进先出（默认）

3、优势和缺点

（1）优点

- 能够实现消息的异步传递。
- 消息是按照顺序逐个处理的，避免了数据的混乱。
- 可以实现复杂的通信，如多个进程可以同时向队列发送和接收消息。
- 支持消息的选择性接收，进程可以根据消息的类型选择读取。

（2）缺点（主要）

- **系统资源限制**：消息队列是一种系统级资源，受到操作系统管理和限制。每个消息队列的大小和系统中可以创建的队列数量通常都有上限
- **内容固定**：一旦消息被发送到队列中，通常就无法被修改。如果发送过程中出现错误，就需要发送新的更正消息
- **同步问题**：消息队列本身并不提供同步机制。当多个进程同时访问同一消息队列时，需要额外的同步操作来管理消息的发送和接收



##### 3、消息队列的使用流程

- 创建或获取消息队列
  - 使用ftok函数获取唯一的消息队列key
  - 使用msgget，利用key来拿到消息队列的id，后续函数就会通过该id来使用
- 进程1利用消息队列的函数msgsnd发送数据
- 其他进程消息队列的函数msgrcv获取数据
- 可选：获取消息队列的状态

##### 4、使用涉及函数

要使用消息队列，那么需要引入`sys/msg.h`头文件。

（1）相关函数

- `msgget`: 用来创建或访问一个消息队列。
- `msgsnd`: 用来向消息队列发送消息。
- `msgrcv`: 从消息队列中接收消息。
- `msgctl`: 控制消息队列的某些属性，如删除队列等

（2）msgget

- 语法

  ```c
  int msgget(key_t key, int msgflg);
  ```

  - 参数
    - `key`: 消息队列的键值，可以是IPC_PRIVATE，或者用ftok()函数生成。
    - `msgflg`: 权限标志，可以与IPC_CREAT（创建消息队列）和IPC_EXCL（与IPC_CREAT一起使用，确保创建新队列）结合使用。 6（所有者）6（同一个用户组）4（其他用户）4 2 1
  - 返回值：**消息队列的id（成功）**或-1（失败）
  - 特点：确保进程有该文件的读写权限

（2）ftok：根据**文件路径的id生成一个唯一值**，用于消息队列作为队列的id值进行使用。`ftok` 是一个Unix标准的函数，它用于将一个文件的id和一个整数标识符转换成一个 System V IPC 键值。这个键值通常用于 `msgget`、`semget` 或 `shmget` 等系统调用中，以创建或访问消息队列、信号量集或共享内存段。

- 语法

  ```c
  #include <sys/ipc.h>
  key_t ftok(const char *pathname, int proj_id);
  ```

  - 参数
    - `pathname`：是一个指向以 null 结尾的字符串的指针，该字符串应代表文件系统中的一个有效文件名的路径。这个文件必须是可访问的（可以不存在），因为 `ftok` 会使用文件的元数据来生成 IPC 键。
    - `proj_id`：是一个整数，用作生成键的另一个输入。为了获得唯一的键值，不同的 `proj_id` 应该和不同的 `pathname` 一起使用。该参数的取值不能为0，并且仅使用其最低的 8 位（即一个字节），因此通常其取值范围为 1 到 255 之间。
  - 返回值
    - 成功时，`ftok` 返回一个类型为 `key_t` 的非零值，即生成的 IPC 键值。
    - 失败时，返回 -1，并且 `errno` 会被设置为指明错误原因的错误码。

（2）msgsnd

- 语法

  ```c
  int msgsnd(int msqid, const void *msgp, size_t msgsz, int flag);
  ```

  - 参数
    - `msqid`: `msgget`函数返回的消息队列标识符。
    - `msgp`: 指向准备发送的消息的指针。指结构体的指针
    - `msgsz`: 消息的大小。指具体信息的大小， 不是结构体的大小
    - `flag`: 消息发送行为的选项，如IPC_NOWAIT（非阻塞发送）
      - 0：非阻塞发送，常规模式，即IPC_NOWAIT，发送后不会等待接受发送完毕就继续执行其他的代码，就不会等接受,如果没有数据会报错
  - 返回值：成功返回0，失败返回-1

（3）msgrcv

- 语法

  ```c
  ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
  ```

  - 参数
    - `msqid`: `msgget`函数返回的消息队列标识符。
    - `msgp`: 用于接收消息的缓冲区。指向消息结构体指针
    - `msgsz`: 缓冲区的大小。结构体的大小
    - `msgtyp`: 请求的消息类型。
    - `msgflg`: 消息接收行为的选项，如IPC_NOWAIT（非阻塞接收）
  - 成功返回消息数据的长度，失败返回-1

（4）msgctl

- 语法

  ```c
  int msgctl(int msqid, int cmd, struct msqid_ds *buf);
  ```

  - 参数
    - msqid：消息队列的标识符，由 msgget 函数返回。
    - cmd：指定要执行的操作。可以是以下几种之一：
      - IPC_STAT：获取消息队列的当前状态，将状态信息存储在 buf 指向的 msqid_ds 结构中。
      - IPC_SET：设置消息队列的属性，根据 buf 指向的 msqid_ds 结构中的值来更新消息队列的属性。只有特定的字段可以被设置，包括 msg_perm.uid、msg_perm.gid、msg_perm.mode 和 msg_qbytes。
      - IPC_RMID：立即删除消息队列，并唤醒所有等待该队列的进程。这个操作不需要 buf 参数。
      - IPC_INFO（非标准）：获取系统范围内消息队列的限制和参数信息。
      - MSG_INFO（非标准）：获取系统范围内消息队列的使用统计信息。
      - MSG_STAT（非标准）：获取消息队列的索引信息，类似于 IPC_STAT，但是是通过消息队列的索引号而不是 msqid。
    - buf：指向 msqid_ds 结构的指针，用于在 IPC_STAT 和 IPC_SET 操作中传递和接收消息队列的属性。msqid_ds 结构通常包含以下字段：
      - msg_perm：消息队列的权限和所有者信息。
      - msg_qnum：队列中的消息数量。
      - msg_qbytes：队列允许的最大字节数。
      - msg_lspid：最后发送消息的进程的进程ID。
      - msg_lrpid：最后接收消息的进程的进程ID。
      - msg_stime：最后发送消息的时间。
      - msg_rtime：最后接收消息的时间。
      - msg_ctime：最后更改队列的时间。
  - 成功返回0， 失败返回-1

##### 5、使用例子

（1）消息队列-写.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <string.h>

struct my_msgbuf {
    long mtype;
    char mtext[200];
};

int main() {
    // 定义一个消息缓冲区结构体
    struct my_msgbuf buf;
    memset(&buf,0,sizeof(buf));
    // 定义一个消息队列标识符
    int msqid;
    // 定义一个键值
    key_t key;

    // 使用ftok函数生成键值
    if ((key = ftok("./fifotest", 'B')) == -1) { /* 同发送方使用同样的key */
        // 如果生成键值失败，则打印错误信息并退出程序
        perror("ftok");
        exit(1);
    }

    // 使用msgget函数连接到消息队列
    if ((msqid = msgget(key, 0644 | IPC_CREAT)) == -1) { 
        /* 连接到队列 */
        // 如果连接失败，则打印错误信息并退出程序
        perror("msgget");
        exit(1);
    }
    //写一条type为2 的信息
    strncpy(buf.mtext, "这是消息的主题：测试数据", sizeof(buf.mtext) - 1);
    buf.mtype = 2;
    msgsnd(msqid,&buf,strlen(buf.mtext) +1 ,0);
    //提示
    printf("消息已经发出,type为2");

    return 0;
}
```

（2）消息队列-读.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <string.h>

struct my_msgbuf {
    long mtype;
    char mtext[200];
};

int main() {
    // 定义一个消息缓冲区结构体
    struct my_msgbuf buf;
    memset(&buf, 0, sizeof(struct my_msgbuf));
    // 定义一个消息队列标识符
    int msqid;
    // 定义一个键值
    key_t key;

    // 使用ftok函数生成键值
    if ((key = ftok("/home/ubuntu/fifotest", 'B')) == -1) { /* 同发送方使用同样的key */
        // 如果生成键值失败，则打印错误信息并退出程序
        perror("ftok");
        exit(1);
    }

    // 使用msgget函数连接到消息队列
    if ((msqid = msgget(key, 0644 | IPC_CREAT)) == -1) { /* 连接到队列 */
        // 如果连接失败，则打印错误信息并退出程序
        perror("msgget");
        exit(1);
    }
    //读一条type为0的信息
    msgrcv(msqid, &buf, sizeof(buf),0,0);
    //提示
    printf("接受的数据为%s\n",buf.mtext);
    return 0; /* 在实际的程序中，你可能需要更多的清理代码 */
}
```

（3）效果展示

![image-20240318143256842](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20240318143256.png)

（4）细节

- 一个消息队列总字节大小

  ```c
  cat /proc/sys/kernel/msgmnb
  ```

  

- 单个消息的字节大小

  ```c
  cat /proc/sys/kernel/msgmax
  ```




#### 四、共享内存

##### 1、概念

- 是一种相比于消息队列和管道更加高效的进程间通信方式。

##### 2、原理

- 虚拟内存和物理内存

操作系统通过内存映射（memory mapping）使不同的进程能够将**同一个物理内存**地址映射到它们各自的虚拟地址空间中。每个进程有自己的虚拟地址空间，操作系统管理这些虚拟地址空间与物理内存的映射。

虚拟内存和物理内存之间的关系：因为每个进程都需要内存空间来管理数据和运行。操作系统为了方便管理不同进程的空间，而设计了虚拟内存机制。一般操作系统对每个进程都采用统一的虚拟内存布局（每个程序可能功能不同，而有所细节区别，一般包括栈、堆、常量区、全局区、代码区等）。以及对每个进程都设置有一样的一定的最大虚拟内存空间**（**根据操作系统位数和系统本身来限制。32位系统通常具有4GB的虚拟地址空间限制，64位系统理论上可以支持非常大的虚拟地址空间：通常在TB级别或更多**）** **该空间就是虚拟内存空间**。但实际进程占有的空间是会对应到物理空间的，并不是一开始就分配等额的空间。即进程**"认为"**自己已经分配到了连续的最大额度的内存空间。但实际上只有真正在使用的那部分物理空间。而操作系统内部会通过**MMU**（内存管理单元）以及嵌入内部的程序来帮助操作系统管理物理空间和虚拟空间之间的转换和联系。

![image-20241103222931024](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/dengnaiwen/20241103222931.png)

- 共享内存
  - 共享内存实际上就是将参与进程通信的多个进程里的虚拟内存一部分映射到同一块物理空间。这就是其原理。当然共享内存的空间大小需要我们指定。**即多个需要数据交互的进程可以访问同一块内存空间**
  - 同时为了降低开发者使用共享内存的难度，定义的操作函数会以类IO操作一样进行使用，即可以简单的把共享内存比喻成一个临时的`文件`，来进行代码编写。方便开发者降低使用成本

##### 3、使用流程

1. 引入对应的头文件

   ```c
   <fcntl.h>：用于文件控制定义，
   <sys/mman.h>：用于内存管理的定义，比如 mmap() 和 munmap() 函数，以及 PROT_READ、PROT_WRITE、MAP_SHARED 等标志。
   <sys/stat.h>：用于文件状态的定义，包括权限标志，比如 0666。
   <unistd.h>：用于定义POSIX标准符号常量和函数声明，比如 ftruncate() 和 close()。
   ```

2. 使用 `shm_open()` 函数创建或打开一个共享内存对象

3. 使用`mmap()`将共享内存映射到进程地址空间,同时返回共享内存的首字节地址

4. 对指针进行操作。任何进程都可以通过该共享内存fd进行处理

5. 如果要保证进程间的访问顺序，则需要考虑同步问题。比如使用信号量

6. 访问完毕并确认不在使用该共享内存，需要使用`mmap`、`close`和`shm_unlink`等函数来删除共享内存

7. 编译时需要加上`-lrt`,因为共享内存需要用到rt库。rt是实时库，它包含了一些和实时操作系统特性相关的函数。

##### 4、相关函数

（1）shm_open():创建或打开一个共享内存

```c
int shm_fd = shm_open("/my_shm", O_CREAT | O_RDWR, 0664);
```

- `"/my_shm"` 是共享内存对象的名称，以斜杠开头。本身不是指的一个文件，只是感觉像在读写一个文件
- `O_CREAT | O_RDWR` 指定了创建和读写权限。
- `0664` 是文件权限。

（2）修改共享内存的大小,

```c
ftruncate(shm_fd, 4096); // 设置大小为4KB
```

- 注意：如果不设置，那么字节数为0，直接读写会报错

（3）将共享内存映射到进程的地址空间

```c
void* ptr = mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
```

- 0或NULL:表示共享内存的起始地址由操作系统自行设置，我们不手动设置共享内存空间的起始地址
- 4096：表示共享内存空间字节总大小
- `PROT_READ | PROT_WRITE` 允许读写操作。
- `MAP_SHARED` 表示多个进程共享这段内存。

（4）关闭共享内存：

```c
munmap(ptr, 4096);
close(shm_fd);
shm_unlink("/my_shm");
```

- munmp:`munmap`函数用于解除内存映射。`ptr`是指向之前通过`mmap`函数映射到进程地址空间的共享内存区域的指针，而`4096`是该映射区域的大小（以字节为单位）
- `close`函数用于关闭文件描述符。`shm_fd`是一个文件描述符，通常是在调用`shm_open`时获得的，用于引用一个打开的共享内存对象
- `shm_unlink`函数用于删除共享内存对象。当共享内存对象不再需要时，通过名称将其删除（在这里是`"/my_shm"`）。但注意，这句话不会马上真正删除共享内存，会在所有相关进程都结束后才会结束。同时调用后的**新的进程**就无法再通过该共享内存名称来访问，目前正在使用共享内存的进程**不受影响**。同时如果进程只是临时退出，下一次要继续使用同一个共享内存，那么这一句不要书写



#### 五、进程间通信的对比

- 进程间通信
  - 管道:适用于简单数据交互的进程通信，优点在于同步，因为一对一，不存在进程同步问题。
    - 无名
    - 有名
  - 消息队列：适用于多对多的进程通信，特别是聊天类的，缺点在于无法实现很复杂的通信
  - 共享内存：优点：效率高，直接访问对应内存进行处理，扩展型。但有同步问题(可以使用信号量)
