一、动态内存分配
1. 回忆C语言中的动态内存分配
    1. malloc() ---- 函数
    2. realloc()
    3. free()
2. C++中的动态内存分配
    1. new/new[] ---- 运算符
    2. delete/delete[]
3. C和C++中动态内存分配new/delete和malloc/free的区别
    1. new/delete是运算符,而malloc/free是函数
    2. new/delete可以自动计算所需内存的大小,而malloc/free需要手动计算所需内存的大小
    3. new/delete可以自动调用构造函数来初始化对象和析构函数来清理对象,相比之下,`malloc`和`free`只负责内存的分配和释放,它们不会调用任何函数。
    4. new/delete可以捕获异常,当`new`无法分配所需的内存时,它会抛出一个异常(通常是`bad_alloc`)，相比之下,如果`malloc`无法分配所需的内存,它只是返回一个空指针。
    5. new/delete返回的是指定类型的指针,而malloc/free返回的是void*类型的指针
    6. 内存对齐**:`new`和`delete`会自动处理对象的内存对齐问题,而`malloc`和`free`则不会。
总的来说使用`new`和`delete`通常更加安全、类型安全和易于管理。在编写C++代码时,推荐优先使用`new`和`delete`。

在C++中如何最大程度避免内存泄露:
    内存泄漏是在C++等编程语言中使用动态内存分配时,由于程序员的错误,导致已经分配的内存没有被正确地释放。
    1. 使用智能指针:智能指针是一种能够自动管理内存的工具。当一个智能指针指向一个对象时,它会在适当的时候自动删除该对象。这可以防止程序员忘记释放内存,从而避免内存泄漏。
    2. 编写清晰的释放逻辑:清晰地定义何时、如何释放内存,并确保在所有可能的执行路径中,这些逻辑都被正确执行。如果在一个函数中分配了内存,那么在函数结束时,应该释放这部分内存。
    3. 使用RAII原则:资源获取即初始化(Resource Acquisition Is Initialization),这是一种编程技巧,可以在创建对象时获取资源,并在对象销毁时释放资源。
    4. 遵循良好的编程习惯:不要在代码中随意使用`new`和`delete`,尽量使用对象生命周期管理,避免一次性申请大量内存等。

C和C++中struct的区别总结:
    1. C语言中的struct不可以包含成员函数,只能包含成员变量，而C++中的struct
    3. C语言中struct定义变量需要添加struct关键字,而C++中可以省略。

C++中，如果没有特别的要求，把属性设置为private访问权限，把方法设置为public访问权限，这样可以提高安全性。
在C++中,封装是通过将数据成员设置为私有(private),而将公共(public)成员函数设置为访问器(accessor)和修改器(mutator)来实现的。